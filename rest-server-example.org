#+TITLE: Servidor REST em Common Lisp
#+LANGUAGE:  pt_BR
#+AUTHOR:    Lucas S. Vieira
#+EMAIL:     lucasvieira@protonmail.com
#+STARTUP:   inlineimages content latexpreview
#+PROPERTY:  header-args:lisp :noweb strip-export :eval no :tangle no
#+OPTIONS:   toc:nil title:nil

* Sumário :TOC:
- [[#introdução][Introdução]]
- [[#dependências][Dependências]]
  - [[#sistemas][Sistemas]]
  - [[#programas][Programas]]
  - [[#utilitários-extras][Utilitários extras]]
- [[#definindo-o-projeto][Definindo o Projeto]]
  - [[#definição-do-system][Definição do System]]
  - [[#definição-dos-pacotes][Definição dos pacotes]]
- [[#inicialização-do-servidor][Inicialização do servidor]]
  - [[#dados-globais-do-servidor][Dados globais do servidor]]
  - [[#iniciando-o-servidor][Iniciando o servidor]]
  - [[#encerrando-o-servidor][Encerrando o servidor]]
- [[#rotas][Rotas]]
  - [[#relação-de-rotas][Relação de rotas]]
  - [[#listagem-de-usuários][Listagem de usuários]]
  - [[#registrar-usuário][Registrar usuário]]
- [[#banco-de-dados][Banco de dados]]
  - [[#usando-postgresql-pelo-docker][Usando PostgreSQL pelo Docker]]
  - [[#criando-um-banco-de-dados][Criando um banco de dados]]
  - [[#conexão-com-o-banco-de-dados][Conexão com o banco de dados]]
  - [[#migrações][Migrações]]
  - [[#seeds][Seeds]]
  - [[#modelos][Modelos]]
  - [[#controladores][Controladores]]
- [[#utilitários][Utilitários]]
  - [[#obtendo-elemento-de-uma-alist-ao-usar-macros][Obtendo elemento de uma alist ao usar macros]]
  - [[#validando-um-json-para-uma-rota][Validando um JSON para uma rota]]
  - [[#validando-uma-alist-de-usuário-para-registro][Validando uma alist de usuário para registro]]

* Introdução

O  objetivo deste  projeto  é  criar um  sistema  de gerenciamento  de
usuários de um sistema, o que inclui /login/ e uma /lista de atividades/.

Este projeto está sendo  desenvolvido através de programação instruída
(/literate programming/),  de forma a  apresentar um exemplo  prático de
aplicação REST, feita totalmente em Common Lisp.

Esta aplicação  procura seguir um padrão  /Model-View-Controller/ (MVC),
comunicando-se primariamente através do formato JSON.

* Dependências

** Sistemas

Em Common  Lisp, aplicações são  divididas em pacotes  (/packages/), que
por sua vez, são redistribuidos em sistemas (/systems/).

Carregar um /system/ significa colocar todos os /packages/ do mesmo no seu
ambiente  da imagem  Lisp  em execução,  de forma  que  os objetos  do
ecossistema possam ser acessados e manipulados em runtime.

Para criar nosso servidor REST, carregaremos os seguintes /systems/:

- [[https://github.com/joaotavora/snooze][Snooze]], para criação de aplicações REST;
- [[https://quickref.common-lisp.net/clack.html][Clack]], servidor que trabalha sob o Snooze;
- [[https://quickref.common-lisp.net/cl-json.html][cl-json]], para /parsing/ e serialização de informações em JSON;
- [[https://github.com/fukamachi/mito][Mito]], para interação com o banco de dados;
- [[https://github.com/sharplispers/ironclad][Ironclad]], para operações relacionadas a criptografia.

# TODO: Ver mito-auth para autenticação do usuário.

** Programas

Os programas  a seguir serão  utilizados neste projeto para  lidar com
algumas dependências, em especial as da aplicação a ser desenvolvida.

- [[https://github.com/roswell/roswell][Roswell]]: Instalador e launcher para aplicações Common Lisp.
- [[http://www.sbcl.org/][SBCL]]: Steel Bank Common Lisp;  compilador de Common Lisp, instalável
  via Roswell.
- [[https://www.quicklisp.org/beta/][Quicklisp]]:  Gerenciador  de  bibliotecas   e  projetos  para  Common
  Lisp.  Com ele,  é possível  definir e  instalar localmente  /systems/
  pertinentes  para  seus  projetos.  É  incluido  automaticamente  na
  configuração do Roswell.
- [[https://github.com/fukamachi/qlot][Qlot]]:   Gerenciador   de   bibliotecas   por   projeto   de   Common
  Lisp. Basicamente,  instala uma versão  do Quicklisp para  o projeto
  atual  e usa-a  neste projeto.  Assim, não  será necessário  incluir
  nosso /system/ no diretório ~local-projects~  do Roswell, por exemplo, e
  poderemos definir versões fixas das bibliotecas que utilizarmos.
- [[https://github.com/fukamachi/mito][Mito]]: Trata-se do mesmo /system/ para conexão do banco de dados, porém
  instalaremos  seu   utilitário  de   console  para   gerenciarmos  o
  versionamento de migrações.

*** Dependências opcionais

- [[https://www.gnu.org/software/emacs/][Emacs]] e  [[https://github.com/slime/slime][SLIME]]: Utilizo o editor  de texto Emacs para  escrever este
  documento e programar  o projeto em questão. Também  utilizo o SLIME
  (Superior Lisp Interaction Mode for Emacs) para executar e interagir
  ao vivo  com o projeto, enquanto  ele executa.
 
Há editores de  texto alternativos e diferentes formas  de se conectar
  um servidor  [[https://github.com/brown/swank-client][Swank]] de  Common Lisp (por  exemplo, os  projetos [[https://github.com/kovisoft/slimv][Slimv]]
  para [[https://www.vim.org/][Vim]]  ou [[https://atom.io/packages/slima][SLIMA]]  para [[https://atom.io/][Atom]]). Ainda  assim, caso  esteja disposto,
  recomendo que aprenda a utilizar as  ferramentas pelo Emacs, que é o
  editor livre padrão   para os usuários de Common Lisp.

*** Configurando o Roswell

É  possível   instalar  o   Roswell  em  várias   distribuições  Linux
existentes. Em  especial, a distribuição  Void Linux (que  utilizo) já
possui  o mesmo  em seus  repositórios. Caso  você precise  instalá-lo
manualmente, siga o repositório do [[https://github.com/roswell/roswell][Roswell]].

Após  sua instalação,  abra  o  console e  utilize  a ferramenta  para
instalar a versão pré-compilada do SBCL:

#+begin_src bash :tangle no :eval no
ros install sbcl-bin
#+end_src

Você  poderá executar  este comando  esporadicamente para  atualizar o
SBCL. Não  é necessário instalar o  SBCL no sistema, o  Roswell poderá
gerenciar isto para você.

Caso você  instale outra  implementação de  Common Lisp  pelo Roswell,
recomendo trocar novamente para o SBCL com o comando:

#+begin_src bash :tangle no :eval no
ros use sbcl-bin
#+end_src

*** Configurando o Qlot

O Qlot  pode ser instalado facilmente  via Roswell, porém, como  não é
uma implementação alternativa  de Common Lisp (e sim  um utilitário do
mesmo que pode ser usado pelo console), basta executarmos:

#+begin_src bash :tangle no :eval no
ros install qlot
#+end_src

Em seguida,  na raiz do projeto,  criamos um arquivo com  o exato nome
~qlfile~, que  lista as bibliotecas e  a versão das mesmas  que queremos
utilizar, da forma como se vê a seguir:

#+begin_src fundamental :tangle qlfile
ql cl-json  2020-03-25
ql snooze   2020-03-25
ql clack    2020-03-25
ql mito     2020-03-25
ql ironclad 2020-03-25
#+end_src

Nosso último  passo é executar  o ~qlot~  no console para  que Quicklisp
seja instalado para este projeto:

#+begin_src bash :tangle no :eval no
qlot install
#+end_src

Isto também criará um arquivo ~qlfile.lock~ na raiz do seu repositório.

Não se  esqueça de adicionar  o diretório  ~.qlot~ ao ~.gitignore~  do seu
repositório Git.

**** Dica sobre o SLIME

Caso você esteja  utilizando Emacs com SLIME, poderá forçar  o SLIME a
usar a instalação local de Quicklisp  do Qlot. Para tanto, adicione às
suas configurações do Emacs a função:

#+begin_src emacs-lisp :eval no :tangle no
(defun slime-qlot-exec (directory)
  (interactive (list (read-directory-name "Project directory: ")))
  (slime-start :program "qlot"
               :program-args '("exec" "ros" "-S" "." "run")
               :directory directory
               :name 'qlot
               :env (list (concat "PATH="
                                  (mapconcat 'identity
                                             exec-path
                                             ":")))))
#+end_src

E então,  ao invés de executar  ~slime~ para iniciar a  imagem Lisp, use
~slime-qlot-exec~, e então selecione o diretório raiz da aplicação.

*** Configurando o mito

Mito também é uma aplicação  que será instalada globalmente através do
Roswell. Para tanto, execute o seguinte comando:

#+begin_src bash :eval no :tangle no
ros install mito
#+end_src

Após a compilação do /system/ Mito, que será instalado globalmente, você
poderá usar o script ~mito~ através da linha de comando.

** Utilitários extras

Estes utilitários  não dizem respeito  diretamente a Common  Lisp, mas
serão usados para  que a aplicação seja desenvolvida.  Esta lista pode
mudar.

- [[https://www.electronjs.org/apps/postbird][Postbird]], para consultar  diretamente o banco de  dados PostgreSQL e
  criar tabelas manualmente;
- [[https://insomnia.rest/][Insomnia]], para testar requisições REST;
- [[https://www.docker.com/][Docker]], para utilização do PostgreSQL dentro de um contêiner.

* Definindo o Projeto

** Definição do System
:PROPERTIES:
:header-args:lisp: :tangle rest-server-example.asd
:END:

O primeiro passo  para a definição de  um projeto é a  definição de um
/system/ do  ASDF, que nada mais  é que uma listagem  de propriedades do
projeto, dependências  a serem obtidas através  do Quicklisp (processo
realizado automaticamente no carregamento  deste /system/) e listagem de
diretórios e arquivos do projeto.

Um /system/ pode  ser compreendido como uma coleção de  /pacotes/. Uma vez
que o /system/  é carregado, os pacotes tornam-se  disponíveis na imagem
Lisp e podem ser utilizados como requisitados.

Normalmente, /systems/ são definidos em  arquivos com extensão =*.asd=, no
diretório do projeto,  e o arquivo costuma ter o  mesmo nome do /system/
que define.

#+begin_src lisp
(asdf:defsystem #:rest-server-example
    :description "Exemplo de um servidor REST."
    :author "Lucas S. Vieira <lucasvieira@protonmail.com>"
    :license "MIT"
    :version "0.0.1"
    :serial t
    :depends-on (#:cl-json
                 #:snooze
                 #:clack
                 #:mito
                 #:ironclad)
    :components
    ((:file "package")
     (:module "src"
       :components ((:file "util")
                    (:file "routes")
                    (:file "server")
                    (:file "db")
                    (:module "models"
                      :components ((:file "user")))))))
#+end_src

** Definição dos pacotes
:PROPERTIES:
:header-args:lisp: :tangle package.lisp
:END:

A  seguir, definiremos  os  pacotes do  projeto. Simplificaremos  este
processo através  da definição  de um  único arquivo  =package.lisp=, na
raiz do projeto, que define todos os pacotes a serem utilizados.

*** Definição do pacote de utilitários

Este  pacote de  utilitários possui  funções e  macros auxiliares  que
podem ser usados globalmente.

#+begin_src lisp
(defpackage #:rest-server.util
  (:nicknames #:util)
  (:use #:cl)
  (:export #:agetf
           #:route-validate-json
           #:post-valid-user-p))
#+end_src

*** Definição do pacote de banco de dados

Este pacote engloba todas as operações relacionadas ao banco de dados,
o que também inclui /models/ e /controllers/.

#+begin_src lisp
(defpackage #:rest-server.db
  (:nicknames #:db)
  (:use #:cl #:mito)
  (:export #:db-connect
           #:db-disconnect
           #:into-json
           #:into-alist
           #:from-alist
           #:user))
#+end_src

*** Definição do pacote principal

Este pacote  engloba as  operações principais  da aplicação,  como seu
ponto de entrada para que a  aplicação seja iniciada ou encerrada, bem
como suas /rotas/.

#+begin_src lisp
(defpackage #:rest-server
  (:nicknames #:restmain)
  (:use #:cl #:snooze)
  (:export #:start-server
           #:stop-server))
#+end_src

* Inicialização do servidor
:PROPERTIES:
:header-args:lisp: :tangle src/server.lisp
:END:

#+begin_src lisp
(in-package #:rest-server)
#+end_src

O  primeiro passo  da  nossa aplicação  é fazer  com  que a  aplicação
conecte-se ao banco  de dados e então inicie o  servidor REST na porta
padrão da aplicação (~9003~).

** Dados globais do servidor

Iniciamos  definindo dois  parâmetros. O  primeiro é  o /handle/  para o
servidor, criado pelo  pacote ~clack~, que será uma  instância pela qual
poderemos gerenciá-lo.  Este /handle/ será modificado  mediante início e
encerramento do servidor.

O segundo é  o valor de configuração  para a /porta/ na  qual o servidor
operará, ouvindo mensagens de acordo com o necessário.

#+begin_src lisp
(defparameter *server-handler* nil)
(defparameter *server-port* 9003)
#+end_src

** Iniciando o servidor

Quando  esta função  é  chamada, caso  o servidor  já  não tenha  sido
iniciado, ele  se conectará ao banco  de dados, e então  o /handle/ será
atualizado  com uma  instância  de um  servidor  do ~clack~,  finalmente
retornando o símbolo ~T~ mediante sucesso.

#+begin_src lisp
(defun start-server ()
  (unless *server-handler*
    (db:db-connect)
    (setf *server-handler*
          (clack:clackup (snooze:make-clack-app)
                         :port *server-port*))
    t))
#+end_src

** Encerrando o servidor

Quando esta função é chamada, caso o servidor esteja ativo, o servidor
~clack~ será interrompido e o /handle/ assumirá o valor ~NIL~. Finalmente, a
aplicação se desconectará do banco de dados, retornando, finalmente, o
símbolo ~T~ no encerramento.

#+begin_src lisp
(defun stop-server ()
  (when *server-handler*
    (clack:stop *server-handler*)
    (setf *server-handler* nil)
    (db:db-disconnect)
    t))
#+end_src

* Rotas
:PROPERTIES:
:header-args:lisp: :tangle src/routes.lisp
:END:

#+begin_src lisp
(in-package #:rest-server)
#+end_src

O arquivo =src/routes.lisp= engloba rotas da aplicação, sendo a porta de
entrada e saída do servidor para com o /frontend/.

A   aplicação  responde   com   seu  ponto   de   entrada  padrão   em
~localhost:9003~.

** Relação de rotas

Esta é a relação de métodos e rotas da aplicação, bem como as entradas
e  saídas esperadas  mediante  sucesso. Absolutamente  todas as  rotas
recebem e enviam JSON em forma de /string/.

|--------+------------+----------------------+----------------------|
| Método | Rota       | Entrada              | Saída                |
|--------+------------+----------------------+----------------------|
| GET    | ~/users~     | -                    | Lista de usuários.   |
| GET    | ~/users/:id~ | -                    | Dados de um usuário. |
| POST   | ~/users~     | Dados de um usuário. | Mensagem de OK.      |
|--------+------------+----------------------+----------------------|

** Listagem de usuários

Esta definição trata dos seguintes métodos e rotas:

- ~GET /users~
- ~GET /users/id~

Estes  métodos retornam  arquivos JSON  com os  dados de  todos ou  um
usuário, respectivamente.

#+begin_src lisp
(defroute users (:get "application/json" &optional (id 'all))
  (if (eq id 'all)
      (json:encode-json-to-string
       (mapcar #'db:into-alist (mito:select-dao 'db:user)))
      (let ((the-user (mito:find-dao 'db:user :id id)))
        (if (null the-user)
            (http-condition 404 "Unknown user ID")
            (db:into-json the-user)))))
#+end_src

** Registrar usuário

Esta definição trata dos métodos e rotas:

- ~POST /users~
- ~POST /users/id~

...onde a primeira requisição é a esperada, e a segunda rota é /inválida/.

A requisição ~POST~  em ~/users~ espera por um arquivo  JSON válido com os
seguintes campos, para que um usuário seja registrado no sistema:

# TODO: Trocar isto  para que seja automático. Talvez  criar um método
# para  cada model  que  envolva obter  a lista  de  campos da  tabela
# automaticamente. Talvez o mito faça isso pra gente.

- ~name~ -- Nome do usuário;
- ~birthdate~  --  Data  de  aniversário com  fuso  horário.  Exemplo:
  ="1990-01-01 12:00:00-03"=;
- ~address~ -- Endereço do usuário;
- ~mail~ -- E-mail do usuário;
- ~pass~ -- Senha do usuário registrado em texto plano.

Caso  os  dados  sejam  válidos  e o  usuário  seja  registrado,  será
retornado um JSON:

#+begin_src json :tangle no
{ "message": "Ok" }
#+end_src

# TODO: Receber senha em texto plano é algo viável mesmo? Será que
# não seria  melhor fazer o  hash no client-side  ou ao menos  falar a
# respeito de SSL?

Abaixo, definimos tais rotas.

#+begin_src lisp
(defroute users (:post "application/json" &optional id)
  (if id
      (http-condition 403 "Route does not accept POST.")
      (let ((object (util:route-validate-json (payload-as-string))))
        (if (not (util:post-valid-user-p object))
            (http-condition 400 "Malformed user data")
            (handler-case (let ((user (db:from-alist :user object)))
                            (mito:insert-dao user) ; todo: verify
                            (json:encode-json-to-string
                             '((message . "Ok"))))
              (error (e)
                (declare (ignore e))
                (http-condition 400 "Malformed user data")))))))
#+end_src

* Banco de dados

Configuraremos  algumas   opções  relacionadas   ao  banco   de  dados
agora. Começaremos gerando um contêiner local para acesso aos dados, e
utilizaremos  Docker  para  gerenciá-lo;  em  seguida,  trataremos  da
conexão, e então de modelos e controladores.

As operações  relacionadas à  conexão e ao  gerenciamento do  banco de
dados, uma vez criado, foi consultada na documentação do pacote ~mito~ e
no [[https://lispcookbook.github.io/cl-cookbook/databases.html][The Common Lisp Cookbook]].

** Usando PostgreSQL pelo Docker

Usaremos Docker para  criar um banco de dados  com PostgreSQL, chamado
=cl-rest=, com uma senha =docker=. Redirecionaremos a porta padrão =5432= do
contêiner para a máquina, e faremos a imagem a partir de PostgreSQL 11.

#+begin_src bash :eval no
docker run --name cl-rest -e POSTGRES_PASSWORD=docker -p 5432:5432 -d postgres:11
#+end_src

#+RESULTS:
: d6cdbe8e7697835291043db255d84d1dd69a44dcaa46ce207df38eebdecda56c

Uma dica  útil é que podemos  ver quais contêineres estão  em execução
usando o comando:

#+begin_src bash
docker ps
#+end_src

#+RESULTS:
| CONTAINER    | ID          | IMAGE                | COMMAND | CREATED | STATUS | PORTS | NAMES |       |   |        |                        |         |
| d6cdbe8e7697 | postgres:11 | docker-entrypoint.s… | About   | a       | minute | ago   | Up    | About | a | minute | 0.0.0.0:5432->5432/tcp | cl-rest |

...ou ver todos os contêineres da máquina com:

#+begin_src bash
docker ps -a
#+end_src

#+RESULTS:
| CONTAINER    | ID          | IMAGE                | COMMAND | CREATED | STATUS | PORTS  | NAMES |       |       |        |                        |         |
| d6cdbe8e7697 | postgres:11 | docker-entrypoint.s… | About   | a       | minute | ago    | Up    | About | a     | minute | 0.0.0.0:5432->5432/tcp | cl-rest |
| b27dfc60f958 | postgres:11 | docker-entrypoint.s… | 5       | weeks   | ago    | Exited | (0)   |     4 | weeks | ago    | database               |         |

Podemos  também  utilizar  os  comandos  a  seguir  para  controlar  o
contêiner.

#+begin_src bash :eval no
docker start cl-rest # Inicia o contêiner
docker stop cl-rest  # Mata o contêiner
docker logs cl-rest  # Mostra os logs do contêiner
#+end_src

** Criando um banco de dados

Faremos, agora, a  operação manual de criar um banco  de dados no SGBD
PostgreSQL. Para tanto, recomendo utilizar o Postbird.

Conecte-se  ao PostgreSQL  através do  Postbird, e  crie uma  /database/
chamada =cl-rest=. As  tabelas e demais elementos  serão criados através
de código, principalmente  usando o pacote ~mito~, uma  solução ORM para
Common Lisp.

** Conexão com o banco de dados
:PROPERTIES:
:header-args:lisp: :tangle src/db.lisp
:END:

#+begin_src lisp
(in-package #:rest-server.db)
#+end_src

Vamos definir  algumas funções que conectam  o ~mito~ ao nosso  banco de
dados recém-criado.

*** Definições globais

Vamos explicitar alguns dados de conexão com o PostgreSQL. Idealmente,
armazenaríamos estas informações em outro lugar, para evitar problemas
de segurança.

#+begin_src lisp
(defparameter *db-username* "postgres")
(defparameter *db-dbname*   "cl-rest")
(defparameter *db-pass*     "docker")
#+end_src

*** Iniciando a conexão

A função  a seguir pode ser  chamada para iniciar uma  conexão entre o
~mito~ e  o PostgreSQL. Aqui, fornecemos  o usuário, o nome  do banco de
dados e a senha do serviço.

#+begin_src lisp
(defun db-connect ()
  (mito:connect-toplevel
   :postgres
   :username      *db-username*
   :database-name *db-dbname*
   :password      *db-pass*))
#+end_src

A   conexão   do   ~mito~   é   globalmente   acessível   no   parâmetro
~mito:*connection*~.

*** Encerrando a conexão

A função a seguir invoca diretamente o ~mito~ para que encerre a conexão
com o banco de dados, caso esteja ativa.

#+begin_src lisp
(defun db-disconnect ()
  (mito:disconnect-toplevel))
#+end_src

** Migrações
:PROPERTIES:
:header-args:lisp: :tangle src/db.lisp
:END:

# TODO:  Versionamento  de migrações  é  feito  através da  ferramenta
# "mito",  instalável  via Roswell.  Vai  demandar  um pouco  mais  de
# estudo.

Realizar    migrações    com    o    ~mito~    é    algo    extremamente
simples.  Primeiramente, definiremos  uma  lista de  todas as  tabelas
existentes, cada qual  correspondente a um /model/ que  também faz parte
do pacote atual, mas é definida em seu respectivo arquivo.

#+begin_src lisp
(defparameter *db-tables* '(user))
#+end_src

A função  a seguir  mapeia a  função ~mito:ensure-table-exists~  sobre a
lista de tabelas esperada, garantindo que todas as tabelas existam.

#+begin_src lisp
(defun db-ensure-tables ()
  (mapcar #'mito:ensure-table-exists *db-tables*))
#+end_src

Já a função a seguir realiza as /migrações/ propriamente ditas, mapeando
~mito:migrate-table~ sobre todas as tabelas da lista. Assim, caso alguma
definição das classes  no ORM tenha sido alterada,  ~mito~ realizará uma
operação de ~ALTER TABLE~ necessária.

#+begin_src lisp
(defun db-migrate-tables ()
  (mapcar #'mito:migrate-table *db-tables*))
#+end_src

Você poderá verificar  o código SQL a ser executado  antes da migração
através da função ~mito:migration-expressions~,  seguido do símbolo para
a tabela criada.  A função auxiliar a seguir mapeia  esta função sobre
todas as  tabelas e  coleta os códigos  de migração  pretendidos, para
cada tabela que necessita de migração.

#+begin_src lisp
(defun db-migration-expressions ()
  (loop for table in *db-tables*
     for expr = (mito:migration-expressions table)
     when expr
     collect (list table expr)))
#+end_src

A função auxiliar  a seguir toma as expressões SQL  necessárias para a
definição das tabelas 

#+begin_src lisp
(defun db-table-definitions ()
  (loop for table in *db-tables*
     for expr = (mito:table-definition table)
     collect (list table expr)))
#+end_src

Finalmente, a função a seguir apenas executa as funções de garantia de
existência e migração automaticamente.

#+begin_src lisp
(defun db-gen-tables ()
  (db-ensure-tables)
  (db-migrate-tables))
#+end_src

*** Executando as migrações pelo console

Antes de  gerarmos as tabelas  de fato,  podemos executar o  ~mito~ pelo
console  para que  este gere  arquivos  ~.sql~ das  migrações, com  seus
respectivos timestamps.

Esta opção  é muito útil  caso você  queira garantir que  suas tabelas
sejam versionadas,  e que  o versionamento seja  feito em  seu próprio
arquivo de código SQL.

Para tanto:

1. Navegue até a pasta raiz do projeto;
2. Crie um  diretório chamado ~mito~. Usaremos  este diretório para
   armazenar todos os arquivos ~.sql~ criados pelo ~mito~ no console.

#+begin_src bash :eval no :tangle no
cd /path/to/rest-server-example
mkdir mito
#+end_src

Finalmente,  execute  o comando  a  seguir.  Veja  que ele  utiliza  a
instalação  do  Quicklisp  pelo  Qlot para  criar  as  migrações  como
necessário:

#+begin_src bash :eval no :tangle no
qlot exec mito generate-migrations -t postgres \
     -u postgres -p docker -P 5432 -d cl-rest \
     -s rest-server-example -D ./mito
#+end_src

Destrinchando este comando, temos os seguintes argumentos:

- =-t postgres=: Anuncia que o tipo do  banco de dados a ser utilizado é
  PostgreSQL;
- =-u postgres=:  Anuncia o  nome do  usuário do  banco de  dados. Neste
  caso, sendo ~postgres~;
- =-p docker= Anuncia a senha de acesso do usuário;
- =-P 5432=: Anuncia a porta na qual o banco de dados está operando;
- =-d cl-rest=: Anuncia o nome do banco de dados (~cl-rest~);
- =-D ./mito=: Anuncia o diretório onde as migrações serão armazenadas.

Lembremos sempre que informações sensíveis (usuário e senha do banco
de dados, por  exemplo) são melhor armazenados em um  local de difícil
acesso para o público em geral.

O argumento =-s rest-server-example= deixa  bem claro que vamos carregar
o /system/ do  projeto atual (homônimo ao informado).  Dessa forma, ~mito~
varre  todos  os  pacotes  do  sistema,  em  busca  de  definições  de
tabelas. Ao encontrá-las, ele gera os arquivos SQL necessários para as
mesmas.

Por  conveniência, à  medida  que  o projeto  evoluir,  vou manter  as
migrações geradas neste repositório, constatando as mudanças que foram
efetuadas.

Para avaliar o estado das migrações em questão, podemos usar novamente
o ~mito~, desta vez sem necessidade do respaldo do Qlot:

#+begin_src bash :tangle no :cache yes :exports both :results verbatim :eval no
mito migration-status -t postgres \
     -u postgres -p docker -P 5432 -d cl-rest \
     -D ./mito
#+end_src

#+RESULTS[794b2433a8feb8a1e024e55a54c1bd83190f1140]:
: 
:  Status   Migration ID
: --------------------------
:   down    20200416161815

Agora, podemos finalmente migrar o banco de dados:

#+begin_src bash :tangle no :cache yes :exports both :results verbatim
mito migrate -t postgres \
     -u postgres -p docker -P 5432 -d cl-rest \
     -D ./mito
#+end_src

#+RESULTS[9e53747730c5174881ffd71a0eacf860447b3fba]:
#+begin_example

Applying './mito/schema.sql'...
-> CREATE TABLE "user" (
    "id" BIGSERIAL NOT NULL PRIMARY KEY,
    "name" VARCHAR(80) NOT NULL,
    "birthdate" TIMESTAMPTZ NOT NULL,
    "address" VARCHAR(255) NOT NULL,
    "mail" VARCHAR(64) NOT NULL,
    "pass" VARCHAR(64) NOT NULL,
    "created_at" TIMESTAMPTZ,
    "updated_at" TIMESTAMPTZ
);
-> CREATE UNIQUE INDEX "unique_user_mail" ON "user" ("mail");
-> CREATE TABLE IF NOT EXISTS "schema_migrations" (
    "version" VARCHAR(255) PRIMARY KEY,
    "applied_at" TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
Successfully updated to the version "20200416161815".
#+end_example

**** Scripts para migração

Os comandos anteriores são longos, portanto vamos criar alguns scripts
para  migração em  um diretório  chamado ~scripts~.  Crie-os na  raiz do
projeto:

#+begin_src bash :eval no :tangle no
cd /path/to/rest-server-example
mkdir scripts
#+end_src

Desta vez,  é interessante que  façamos scripts Bash para  executar os
comandos.

Lembremos mais  uma vez que  as informações sensíveis  utilizadas aqui
deveriam  ser  armazenadas em  outro  lugar,  por segurança,  e  então
utilizadas pelos scripts em si.

~scripts/gen-migrations.sh~:

#+begin_src bash :tangle scripts/gen-migrations.sh :eval no
#!/bin/bash
qlot exec mito generate-migrations -t postgres \
     -u postgres -p docker -P 5432 -d cl-rest \
     -s rest-server-example -D ./mito
#+end_src

~scripts/migration-status.sh~:

#+begin_src bash :tangle scripts/migration-status.sh :eval no
#!/bin/bash
mito migration-status -t postgres \
     -u postgres -p docker -P 5432 -d cl-rest \
     -D ./mito
#+end_src

~scripts/migrate.sh~:

#+begin_src bash :tangle scripts/migrate.sh :eval no
#!/bin/bash
mito migrate -t postgres \
     -u postgres -p docker -P 5432 -d cl-rest \
     -D ./mito
#+end_src

O último passo é permitir  que estes arquivos sejam executáveis. Basta
alterar suas permissões com:

#+begin_src bash :eval yes
chmod +x scripts/*.sh
#+end_src

#+RESULTS:

** Seeds
:PROPERTIES:
:header-args:lisp: :tangle src/db.lisp
:END:

A  função a  seguir popula  o banco  de dados  com alguns  exemplos de
dados. Atualmente, apenas dois usuários são inseridos.

#+begin_src lisp
(defun db-seed ()
  (labels ((seed-users (seed)
             (loop for user in seed
                do (mito:insert-dao
                    (make-instance
                     'user
                     :name (util:agetf :name user)
                     :birthdate (util:agetf :birthdate user)
                     :address (util:agetf :address user)
                     :mail (util:agetf :mail user)
                     :pass (util:agetf :pass user))))))
    (seed-users '(((:name      . "Fulano da Silva")
                   (:birthdate . "1990-01-01 12:00:00-03")
                   (:address   . "Rua dos Bobos, 0")
                   (:mail      . "fulano@exemplo.com")
                   (:pass      . "123456"))
                  ((:name      . "Ciclano da Silva")
                   (:birthdate . "1990-01-01 12:00:00-03")
                   (:address   . "Rua dos Bobos, 1")
                   (:mail      . "ciclano@exemplo.com")
                   (:pass      . "123456"))))))
#+end_src

** Modelos

As  próximas  definições  tratam  de /modelos/  da  aplicação,  que  são
correspondentes também  a tabelas da  mesma. Portanto, cada  um destes
modelos encontra-se em um arquivo próprio.

# TODO: Especificar métodos gerais dos modelos

*** Usuário
:PROPERTIES:
:header-args:lisp: :tangle src/models/user.lisp
:END:

#+begin_src lisp
(in-package #:rest-server.db)
#+end_src

Aqui definimos  os campos para  um usuário  do sistema.  Os  campos da
tabela do usuário estão listados a seguir:

|------------+-------------+----------------------------|
| Nome       | Tipo        | Observações                |
|------------+-------------+----------------------------|
| id         | BIGSERIAL   | Automático, chave primária |
| name       | VARCHAR 80  |                            |
| birthdate  | TIMESTAMPTZ |                            |
| address    | VARCHAR 255 |                            |
| mail       | VARCHAR 64  | Índice único               |
| pass       | VARCHAR 64  |                            |
| created_at | TIMESTAMPTZ | Automático                 |
| updated_at | TIMESTAMPTZ | Automático                 |
|------------+-------------+----------------------------|

#+begin_src lisp
(defclass user ()
  ((name :col-type (:varchar 80)
         :initarg :name
         :accessor user-name)
   (birthdate :col-type :timestamptz
              :initarg :birthdate
              :accessor user-birthdate)
   (address :col-type (:varchar 255)
            :initarg :address
            :accessor user-address)
   (mail :col-type (:varchar 64)
         :initarg :mail
         :accessor user-mail)
   (pass :col-type (:varchar 64)
         :initarg :pass
         :accessor user-pass))
  (:metaclass mito:dao-table-class)
  (:unique-keys mail))
#+end_src

**** Auxiliares

# TODO: Especificar a  existência deste método em  outro lugar. Talvez
# passar para o controller???

#+begin_src lisp
(defmethod into-alist ((user user))
  `((:id      . ,(mito:object-id user))
    (:name    . ,(user-name user))
    (:birthdate . ,(user-birthdate user))
    (:address . ,(user-address user))
    (:mail    . ,(user-mail user))
    (:pass    . ,(user-pass user))))
#+end_src

#+begin_src lisp
(defmethod into-json ((user user))
  (json:encode-json-to-string (into-alist user)))
#+end_src

#+begin_src lisp
(defmethod from-alist ((type (eql :user)) alist)
  (macrolet ((get-field (field)
               `(util:agetf ,field alist)))
    (make-instance 'user
                   :name (get-field :name)
                   :birthdate (get-field :birthdate)
                   :address (get-field :address)
                   :mail (get-field :mail)
                   :pass (get-field :pass))))
#+end_src

** Controladores

A fazer.

* Utilitários
:PROPERTIES:
:header-args:lisp: :tangle src/util.lisp
:END:

#+begin_src lisp
(in-package #:rest-server.util)
#+end_src

As funções e macros a seguir  são gerais para a aplicação, podendo ser
utilizados em qualquer lugar. Geralmente são aqui deixados para evitar
poluição no código.

** Obtendo elemento de uma alist ao usar macros

Este macro  tenta obter  o valor  associado a uma  certa chave  em uma
lista  de  atributos  (alist),  caso  exista.  Se  não  existir,  será
retornado ~NIL~.

Este macro  presume que a alist  seja composta de pares  criados com a
função ~CONS~, onde o ~CDR~ não seja uma lista.

#+begin_src lisp
(defmacro agetf (key alist)
  `(cdr (assoc ,key ,alist)))
#+end_src

** Validando um JSON para uma rota

Este macro  toma um certo /payload/  de uma rota qualquer  e verifica se
ele é válido. Caso não seja, é automaticamente ativada uma condição do
protocolo HTTP como  resposta, sob um erro 400 e  uma mensagem de JSON
mal-formado.

#+begin_src lisp
(defmacro route-validate-json (payload)
  (let ((payload-sym (gensym)))
    `(let ((,payload-sym ,payload))
       (handler-case (json:decode-json-from-string
                      ,payload-sym)
         (error (e)
           (declare (ignore e))
           (http-condition 400 "Malformed JSON: ~a" ,payload-sym))))))
#+end_src

** Validando uma alist de usuário para registro

# TODO: Generalizar!!!!!
# TODO: Este formato é  realmente necessário? Não deveríamos converter
# diretamente de uma entidade do mito para JSON e vice-versa?

Esta função  toma uma alist  de dados de  um usuário, pronto  para ser
criado no  banco de dados, e  entao verifica se todos  estes dados são
/strings/, como esperado.

#+begin_src lisp
(defun post-valid-user-p (user-data)
  (let ((fields '(:name :birthdate :address :mail :pass)))
    (loop for field in user-data
       always (and (consp field)
                   (stringp (cdr field))
                   (and (member (car field) fields))))))
#+end_src

