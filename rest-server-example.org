#+TITLE:     Servidor REST em Common Lisp
#+LANGUAGE:  pt_BR
#+AUTHOR:    Lucas S. Vieira
#+EMAIL:     lucasvieira@protonmail.com
#+STARTUP:   inlineimages content latexpreview shrink
#+PROPERTY:  header-args:lisp :noweb strip-export :eval no :tangle no :results silent
#+OPTIONS:   toc:nil title:nil

:LATEX_PROPERTIES:
# Evaluate this block to use a book which starts with chapters instead
# of parts.

#+NAME: setclass
#+begin_src emacs-lisp :tangle no :eval yes :results silent :exports none
(add-to-list 'org-latex-classes
             '("book-noparts"
               "\\documentclass{memoir}"
               ("\\chapter{%s}" . "\\chapter*{%s}")
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))

(setq org-latex-listings 'minted)

nil ;; prevent output
#+end_src

#+CALL: setclass()

# Preamble
# #+LATEX_CLASS: article

#+LATEX_CLASS: book-noparts
#+LATEX_CLASS_OPTIONS: [openright,a4paper,twoside,11pt]

#+LATEX_HEADER: \usepackage[brazil]{babel}
#+LATEX_HEADER: \usepackage{times}
# #+LATEX_HEADER: \usepackage[utf8x]{inputenc}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage{color}
#+LATEX_HEADER: \usepackage{microtype}
#+LATEX_HEADER: \usepackage{titlesec}
#+LATEX_HEADER: \usepackage[english, hyperpageref]{backref}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage[alf,abnt-emphasize=bf,abnt-doi=link]{abntex2cite}
#+LATEX_HEADER: \usepackage{indentfirst}
#+LATEX_HEADER: \usepackage{listings}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{amssymb}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{geometry}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usepackage{fancyhdr}
#+LATEX_HEADER: \usepackage{titling}

# #+LATEX_HEADER: \usepackage{draftwatermark}

# Remove colorization of links
#+LATEX_HEADER: \definecolor{blue}{RGB}{41,5,195}
#+LATEX_HEADER: \makeatletter
#+LATEX_HEADER: \hypersetup{
# #+LATEX_HEADER:     pdftitle={%t},
# #+LATEX_HEADER:     pdfauthor={%a},
# #+LATEX_HEADER:     pdfkeywords={%k},
# #+LATEX_HEADER:     pdfsubject={%d},
# #+LATEX_HEADER:     pdfcreator={%c},
#+LATEX_HEADER:     colorlinks=true,
#+LATEX_HEADER:     linkcolor=black,
#+LATEX_HEADER:     citecolor=black,
#+LATEX_HEADER:     filecolor=black,
#+LATEX_HEADER:     urlcolor=blue,
#+LATEX_HEADER:     bookmarksdepth=4
#+LATEX_HEADER: }
#+LATEX_HEADER: \makeatother
#+BIND: org-latex-hyperref-template ""

# Make watermark softer
# #+LATEX_HEADER: \SetWatermarkLightness{0.85}

# Spacing
# #+LATEX_HEADER: \setlength{\parindent}{1.5cm}
#+LATEX_HEADER: \setlrmarginsandblock{3cm}{2cm}{*}
#+LATEX_HEADER: \setulmarginsandblock{2.5cm}{2.5cm}{*}
#+LATEX_HEADER: \checkandfixthelayout

# Remove indentação de parágrafo
#+LATEX_HEADER: \setlength{\parindent}{0cm}
:END:

:LATEX_CODE_BLOCK_STYLE:
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage{minted}

# Fix Pygments being a bitch
#+LATEX_HEADER: \AtBeginEnvironment{minted}{%
#+LATEX_HEADER:   \renewcommand{\fcolorbox}[4][]{#4}}

#+LATEX_HEADER: \setminted{frame=lines, framerule=2pt}
:END:

:LATEX_COVER:
#+LATEX: \frontmatter

#+LATEX: \makeatletter
#+LATEX: \begin{titlingpage}
#+LATEX: \phantom{xxx}
#+LATEX: \vspace{0.5cm}
#+LATEX: \huge
#+LATEX: \raggedright
#+LATEX: \@author\\
#+LATEX: \vspace{2.5cm}
#+LATEX: \huge 
#+LATEX: {\raggedleft
# #+LATEX: \includegraphics[scale=0.9]{logo.pdf}\\[1cm]
#+LATEX: \textbf{\HUGE\textcolor{blue}{\@title}}\\
#+LATEX: {\large Version 0.2}\\[1cm]
#+LATEX: }
#+LATEX: \centering 
#+LATEX:
#+LATEX: \vfill
#+LATEX: \Large
#+LATEX:
#+LATEX: \vfill
#+LATEX: \@date
#+LATEX: \end{titlingpage}
#+LATEX: \makeatother
:END:

:LATEX_TOC:
#+LATEX: \setcounter{secnumdepth}{6}
#+LATEX: \setcounter{tocdepth}{6}
#+LATEX: \pdfbookmark[0]{\contentsname}{toc}
#+LATEX: \tableofcontents*
#+LATEX: \cleardoublepage

#+LATEX: \mainmatter
:END:

* Sumário :TOC_6:noexport:
- [[#introdução][Introdução]]
- [[#dependências][Dependências]]
  - [[#sistemas][Sistemas]]
  - [[#programas][Programas]]
    - [[#dependências-opcionais][Dependências opcionais]]
    - [[#configurando-o-roswell][Configurando o Roswell]]
    - [[#configurando-o-qlot][Configurando o Qlot]]
      - [[#dica-sobre-o-slime][Dica sobre o SLIME]]
    - [[#configurando-o-mito][Configurando o mito]]
  - [[#utilitários-extras][Utilitários extras]]
- [[#definindo-o-projeto][Definindo o Projeto]]
  - [[#definição-do-system][Definição do System]]
  - [[#definição-dos-pacotes][Definição dos pacotes]]
    - [[#definição-do-pacote-de-utilitários][Definição do pacote de utilitários]]
    - [[#definição-do-pacote-de-banco-de-dados][Definição do pacote de banco de dados]]
    - [[#definição-do-pacote-principal][Definição do pacote principal]]
- [[#inicialização-do-servidor][Inicialização do servidor]]
  - [[#dados-globais-do-servidor][Dados globais do servidor]]
  - [[#iniciando-o-servidor][Iniciando o servidor]]
  - [[#encerrando-o-servidor][Encerrando o servidor]]
- [[#rotas][Rotas]]
  - [[#relação-de-rotas][Relação de rotas]]
  - [[#listagem-de-usuários][Listagem de usuários]]
  - [[#registrar-usuário][Registrar usuário]]
  - [[#autenticar-usuário][Autenticar usuário]]
- [[#banco-de-dados][Banco de dados]]
  - [[#usando-postgresql-pelo-docker][Usando PostgreSQL pelo Docker]]
  - [[#criando-um-banco-de-dados][Criando um banco de dados]]
  - [[#conexão-com-o-banco-de-dados][Conexão com o banco de dados]]
    - [[#definições-globais][Definições globais]]
    - [[#iniciando-a-conexão][Iniciando a conexão]]
    - [[#encerrando-a-conexão][Encerrando a conexão]]
  - [[#migrações][Migrações]]
    - [[#executando-as-migrações-em-código][Executando as migrações em código]]
      - [[#verificando-o-sql-gerado-a-cada-consulta][Verificando o SQL gerado a cada consulta]]
    - [[#executando-as-migrações-pelo-console][Executando as migrações pelo console]]
      - [[#scripts-para-migração][Scripts para migração]]
  - [[#seeds][Seeds]]
  - [[#modelos][Modelos]]
    - [[#usuário][Usuário]]
  - [[#interface-de-controladores][Interface de controladores]]
    - [[#operações-genéricas][Operações genéricas]]
      - [[#index][Index]]
      - [[#show][Show]]
      - [[#store][Store]]
      - [[#update][Update]]
      - [[#delete][Delete]]
- [[#autenticação-de-usuário][Autenticação de Usuário]]
  - [[#gerador-de-json-web-token][Gerador de JSON Web Token]]
    - [[#parâmetros-do-token][Parâmetros do Token]]
    - [[#data-de-criação][Data de criação]]
    - [[#data-de-expiração][Data de expiração]]
    - [[#função-para-resposta-a-requisição-de-sessão][Função para resposta a requisição de sessão]]
  - [[#verificação-de-json-web-token][Verificação de JSON Web Token]]
    - [[#verificação-de-token][Verificação de token]]
    - [[#verificação-de-payload-genérico][Verificação de payload genérico]]
    - [[#verificações-de-métodos-de-controladores][Verificações de métodos de controladores]]
      - [[#verificação-do-index][Verificação do Index]]
      - [[#verificação-do-show][Verificação do Show]]
      - [[#verificação-do-store][Verificação do Store]]
      - [[#verificação-do-update][Verificação do Update]]
      - [[#verificação-do-delete][Verificação do Delete]]
- [[#controladores][Controladores]]
  - [[#controlador-de-usuário][Controlador de Usuário]]
    - [[#index-1][Index]]
    - [[#show-1][Show]]
    - [[#store-1][Store]]
  - [[#controlador-de-sessão][Controlador de Sessão]]
    - [[#store-2][Store]]
- [[#utilitários][Utilitários]]
  - [[#obtendo-elemento-de-uma-alist-ao-usar-macros][Obtendo elemento de uma alist ao usar macros]]
  - [[#preparando-uma-resposta-em-json-do-ningle][Preparando uma resposta em JSON do Ningle]]
  - [[#convertendo-símbolos-para-keywords][Convertendo símbolos para keywords]]
  - [[#convertendo-strings-para-keywords][Convertendo strings para keywords]]
  - [[#reescrevendo-alist-com-pares-em-keywords][Reescrevendo alist com pares em keywords]]
  - [[#tomando-o-payload-do-ningle][Tomando o payload do Ningle]]
  - [[#detectando-se-uma-classe-é-realmente-uma-tabela][Detectando se uma classe é realmente uma tabela]]
  - [[#extraindo-lista-de-slots-de-uma-tabela][Extraindo lista de slots de uma tabela]]
    - [[#colunas-cruas][Colunas cruas]]
    - [[#colunas-em-alists][Colunas em alists]]
    - [[#colunas-em-alists-para-registro][Colunas em alists para registro]]
    - [[#colunas-em-string][Colunas em string]]
    - [[#colunas-em-string-para-registro][Colunas em string para registro]]
  - [[#validando-uma-alist-de-registro][Validando uma alist de registro]]
  - [[#obtendo-campos-de-um-dao][Obtendo campos de um DAO]]
  - [[#censurando-informações-sensíveis-em-uma-alist][Censurando informações sensíveis em uma alist]]
  - [[#campos-censurados-em-um-dao][Campos censurados em um DAO]]
  - [[#obtendo-campos-filtrados-de-um-dao][Obtendo campos filtrados de um DAO]]
  - [[#obtendo-json-de-um-dao-do-banco-de-dados][Obtendo JSON de um DAO do banco de dados]]

* Introdução

O  objetivo deste  projeto  é  criar um  sistema  de gerenciamento  de
usuários de um sistema, o que inclui /login/ e uma /lista de atividades/.

Este projeto está sendo  desenvolvido através de programação instruída
(/literate programming/),  de forma a  apresentar um exemplo  prático de
aplicação REST, feita totalmente em Common Lisp.

Esta aplicação  procura seguir um padrão  /Model-View-Controller/ (MVC),
comunicando-se primariamente através do formato JSON.

* Dependências

** Sistemas

Em Common  Lisp, aplicações são  divididas em pacotes  (/packages/), que
por sua vez, são redistribuidos em sistemas (/systems/).

Carregar um /system/ significa colocar todos os /packages/ do mesmo no seu
ambiente  da imagem  Lisp  em execução,  de forma  que  os objetos  do
ecossistema possam ser acessados e manipulados em runtime.

Para criar nosso servidor REST, carregaremos os seguintes /systems/:

- [[http://8arrow.org/ningle/][Ningle]], para criação de aplicações REST;
- [[https://quickref.common-lisp.net/clack.html][Clack]], servidor que trabalha sob o Snooze;
- [[https://quickref.common-lisp.net/cl-json.html][cl-json]], para /parsing/ e serialização de informações em JSON;
- [[https://github.com/fukamachi/mito][Mito]], para interação com o banco de dados;
- [[https://github.com/fukamachi/mito-auth][mito-auth]], para autenticação do usuário;
- [[https://github.com/sharplispers/ironclad][Ironclad]], para operações relacionadas a criptografia;
- [[https://github.com/fukamachi/jose][JOSE]], para geração de JSON Web Tokens de sessão (JWT);
- [[https://github.com/pcostanza/closer-mop][closer-mop]], para manipulação extra no protocolo de metaobjetos;
- [[https://common-lisp.net/project/alexandria/][Alexandria]], para utilitários variados  relacionados a diversos tipos
  de operações;
- [[https://github.com/nightfly19/cl-arrows][cl-arrows]], para macros de threading como =->= e =->>=;
- [[https://github.com/sharplispers/split-sequence][split-sequence]], para lidar com strings em alguns locais.

# TODO: Ver fukamachi/mito-attachment para  gerenciar arquivos fora do
# SGBD.

** Programas

Os programas  a seguir serão  utilizados neste projeto para  lidar com
algumas dependências, em especial as da aplicação a ser desenvolvida.

- [[https://github.com/roswell/roswell][Roswell]]: Instalador e launcher para aplicações Common Lisp.
- [[http://www.sbcl.org/][SBCL]]: Steel Bank Common Lisp;  compilador de Common Lisp, instalável
  via Roswell.
- [[https://www.quicklisp.org/beta/][Quicklisp]]:  Gerenciador  de  bibliotecas   e  projetos  para  Common
  Lisp.  Com ele,  é possível  definir e  instalar localmente  /systems/
  pertinentes  para  seus  projetos.  É  incluido  automaticamente  na
  configuração do Roswell.
- [[https://github.com/fukamachi/qlot][Qlot]]:   Gerenciador   de   bibliotecas   por   projeto   de   Common
  Lisp. Basicamente,  instala uma versão  do Quicklisp para  o projeto
  atual  e usa-a  neste projeto.  Assim, não  será necessário  incluir
  nosso /system/ no diretório ~local-projects~  do Roswell, por exemplo, e
  poderemos definir versões fixas das bibliotecas que utilizarmos.
- [[https://github.com/fukamachi/mito][Mito]]: Trata-se do mesmo /system/ para conexão do banco de dados, porém
  instalaremos  seu   utilitário  de   console  para   gerenciarmos  o
  versionamento de migrações.

*** Dependências opcionais

- [[https://www.gnu.org/software/emacs/][Emacs]] e  [[https://github.com/slime/slime][SLIME]]: Utilizo o editor  de texto Emacs para  escrever este
  documento e programar  o projeto em questão. Também  utilizo o SLIME
  (Superior Lisp Interaction Mode for Emacs) para executar e interagir
  ao vivo  com o projeto, enquanto  ele executa.
 
Há editores de  texto alternativos e diferentes formas  de se conectar
  um servidor  [[https://github.com/brown/swank-client][Swank]] de  Common Lisp (por  exemplo, os  projetos [[https://github.com/kovisoft/slimv][Slimv]]
  para [[https://www.vim.org/][Vim]]  ou [[https://atom.io/packages/slima][SLIMA]]  para [[https://atom.io/][Atom]]). Ainda  assim, caso  esteja disposto,
  recomendo que aprenda a utilizar as  ferramentas pelo Emacs, que é o
  editor livre padrão   para os usuários de Common Lisp.

*** Configurando o Roswell

É  possível   instalar  o   Roswell  em  várias   distribuições  Linux
existentes. Em  especial, a distribuição  Void Linux (que  utilizo) já
possui  o mesmo  em seus  repositórios. Caso  você precise  instalá-lo
manualmente, siga o repositório do [[https://github.com/roswell/roswell][Roswell]].

Após  sua instalação,  abra  o  console e  utilize  a ferramenta  para
instalar a versão pré-compilada do SBCL:

#+begin_src bash :tangle no :eval no
ros install sbcl-bin
#+end_src

Você  poderá executar  este comando  esporadicamente para  atualizar o
SBCL. Não  é necessário instalar o  SBCL no sistema, o  Roswell poderá
gerenciar isto para você.

Caso você  instale outra  implementação de  Common Lisp  pelo Roswell,
recomendo trocar novamente para o SBCL com o comando:

#+begin_src bash :tangle no :eval no
ros use sbcl-bin
#+end_src

*** Configurando o Qlot

O Qlot  pode ser instalado facilmente  via Roswell, porém, como  não é
uma implementação alternativa  de Common Lisp (e sim  um utilitário do
mesmo que pode ser usado pelo console), basta executarmos:

#+begin_src bash :tangle no :eval no
ros install qlot
#+end_src

Em seguida,  na raiz do projeto,  criamos um arquivo com  o exato nome
~qlfile~, que  lista as bibliotecas e  a versão das mesmas  que queremos
utilizar, da forma como se vê a seguir:

#+begin_src text :tangle qlfile
ql cl-json        2020-03-25
ql ningle         2020-03-25
ql clack          2020-03-25
ql mito           2020-03-25
ql mito-auth      2020-03-25
ql ironclad       2020-03-25
ql jose           2020-03-25
ql closer-mop     2020-03-25
ql alexandria     2020-03-25
ql cl-arrows      2020-03-25
ql split-sequence 2020-03-25
#+end_src

Nosso último  passo é executar  o ~qlot~  no console para  que Quicklisp
seja instalado para este projeto:

#+begin_src bash :tangle no :eval no
qlot install
#+end_src

Isto também criará um arquivo ~qlfile.lock~ na raiz do seu repositório.

Não se  esqueça de adicionar  o diretório  ~.qlot~ ao ~.gitignore~  do seu
repositório Git.

**** Dica sobre o SLIME

Caso você esteja  utilizando Emacs com SLIME, poderá forçar  o SLIME a
usar a instalação local de Quicklisp  do Qlot. Para tanto, adicione às
suas configurações do Emacs a função:

#+begin_src emacs-lisp :eval no :tangle no
(defun slime-qlot-exec (directory)
  (interactive (list (read-directory-name "Project directory: ")))
  (slime-start :program "qlot"
               :program-args '("exec" "ros" "-S" "." "run")
               :directory directory
               :name 'qlot
               :env (list (concat "PATH="
                                  (mapconcat 'identity
                                             exec-path
                                             ":")))))
#+end_src

E então,  ao invés de executar  ~slime~ para iniciar a  imagem Lisp, use
~slime-qlot-exec~, e então selecione o diretório raiz da aplicação.

*** Configurando o mito

Mito também é uma aplicação  que será instalada globalmente através do
Roswell. Para tanto, execute o seguinte comando:

#+begin_src bash :eval no :tangle no
ros install mito
#+end_src

Após a compilação do /system/ Mito, que será instalado globalmente, você
poderá usar o script ~mito~ através da linha de comando.

** Utilitários extras

Estes utilitários  não dizem respeito  diretamente a Common  Lisp, mas
serão usados para  que a aplicação seja desenvolvida.  Esta lista pode
mudar.

- [[https://www.electronjs.org/apps/postbird][Postbird]], para consultar  diretamente o banco de  dados PostgreSQL e
  criar tabelas manualmente;
- [[https://insomnia.rest/][Insomnia]], para testar requisições REST;
- [[https://www.docker.com/][Docker]], para utilização do PostgreSQL dentro de um contêiner.

* Definindo o Projeto

** Definição do System
:PROPERTIES:
:header-args:lisp: :tangle rest-server-example.asd
:END:

O primeiro passo  para a definição de  um projeto é a  definição de um
/system/ do  ASDF, que nada mais  é que uma listagem  de propriedades do
projeto, dependências  a serem obtidas através  do Quicklisp (processo
realizado automaticamente no carregamento  deste /system/) e listagem de
diretórios e arquivos do projeto.

Um /system/ pode  ser compreendido como uma coleção de  /pacotes/. Uma vez
que o /system/  é carregado, os pacotes tornam-se  disponíveis na imagem
Lisp e podem ser utilizados como requisitados.

Normalmente, /systems/ são definidos em  arquivos com extensão =*.asd=, no
diretório do projeto,  e o arquivo costuma ter o  mesmo nome do /system/
que define.

#+begin_src lisp
(asdf:defsystem #:rest-server-example
    :description "Exemplo de um servidor REST."
    :author "Lucas S. Vieira <lucasvieira@protonmail.com>"
    :license "MIT"
    :version "0.1.0"
    :serial t
    :depends-on (#:cl-json
                 #:ningle
                 #:clack
                 #:mito
                 #:mito-auth
                 #:ironclad
                 #:jose
                 #:closer-mop
                 #:alexandria
                 #:cl-arrows
                 #:split-sequence)
    :components
    ((:file "package")
     (:module "src"
       :components ((:file "util")
                    (:file "server")
                    (:file "routes")
                    (:file "db")
                    (:file "jwt")
                    (:module "models"
                      :components ((:file "user")))
                    (:module "controllers"
                      :components ((:file "user-controller")
                                   (:file "session-controller")))))))
#+end_src

** Definição dos pacotes
:PROPERTIES:
:header-args:lisp: :tangle package.lisp
:END:

A  seguir, definiremos  os  pacotes do  projeto. Simplificaremos  este
processo através  da definição  de um  único arquivo  =package.lisp=, na
raiz do projeto, que define todos os pacotes a serem utilizados.

*** Definição do pacote de utilitários

Este  pacote de  utilitários possui  funções e  macros auxiliares  que
podem ser usados globalmente.

#+begin_src lisp
(defpackage #:rest-server.util
  (:nicknames #:util)
  (:use #:cl #:cl-arrows)
  (:export #:agetf
           #:route-prepare-response
           #:http-response
           #:symbol->keyword
           #:class-table-p
           #:table-get-lispy-columns
           #:table-get-lispy-register-columns
           #:table-get-string-columns
           #:table-get-string-register-columns
           #:get-payload
           #:post-valid-data-p
           #:dao->alist
           #:filter-alist
           #:dao->filtered-alist
           #:dao->json)
  (:documentation
   "Utilities and miscellaneous structures for
all other project modules."))
#+end_src

#+RESULTS:
: #<PACKAGE "REST-SERVER.UTIL">

*** Definição do pacote de banco de dados

Este pacote engloba todas as operações relacionadas ao banco de dados,
o que também inclui /models/ e /controllers/.

#+begin_src lisp
(defpackage #:rest-server.db
  (:nicknames #:db)
  (:use #:cl #:mito #:mito-auth #:cl-arrows #:split-sequence)
  (:export #:db-connect
           #:db-disconnect
           #:into-json
           #:into-alist
           #:control-index
           #:control-show
           #:control-store
           #:control-update
           #:control-delete
           #:user)
  (:documentation
   "Utilities related to dealing with the database,
including connection, migrations, models and
controllers."))
#+end_src

*** Definição do pacote principal

Este pacote  engloba as  operações principais  da aplicação,  como seu
ponto de entrada para que a  aplicação seja iniciada ou encerrada, bem
como suas /rotas/.

#+begin_src lisp
(defpackage #:rest-server
  (:nicknames #:restmain)
  (:use #:cl #:cl-arrows #:ningle)
  (:export #:start-server
           #:stop-server)
  (:documentation
   "Default package for the application, containing
routes and routines for starting/stopping the web
server."))
#+end_src

#+RESULTS:
: #<PACKAGE "REST-SERVER">

* Inicialização do servidor
:PROPERTIES:
:header-args:lisp: :tangle src/server.lisp
:END:

#+begin_src lisp
(in-package #:rest-server)
#+end_src

O  primeiro passo  da  nossa aplicação  é fazer  com  que a  aplicação
conecte-se ao banco  de dados e então inicie o  servidor REST na porta
padrão da aplicação (~9003~).

** Dados globais do servidor

Iniciamos  definindo dois  parâmetros. O  primeiro é  o /handle/  para o
servidor, criado pelo  pacote ~clack~, que será uma  instância pela qual
poderemos gerenciá-lo.  Este /handle/ será modificado  mediante início e
encerramento do servidor.

O segundo é  o valor de configuração  para a /porta/ na  qual o servidor
operará, ouvindo mensagens de acordo com o necessário.

#+begin_src lisp
(defparameter *server-handler* nil
  "Default handler for the server. Non-nil when the server
is running.")

(defparameter *server-port* 9003
  "Default port for the server.")
#+end_src

Também precisaremos de um roteador  para as rotas, que serão definidas
a seguir. Este roteador é um aplicativo do system Ningle.

#+begin_src lisp
(defparameter *app* (make-instance 'ningle:<app>))
#+end_src

** Iniciando o servidor

Quando  esta função  é  chamada, caso  o servidor  já  não tenha  sido
iniciado, ele  se conectará ao banco  de dados, e então  o /handle/ será
atualizado  com uma  instância  de um  servidor  do ~clack~,  finalmente
retornando o símbolo ~T~ mediante sucesso.

#+begin_src lisp
(defun start-server ()
  "Initializes the server if it wasn't initialized yet.

Returns T if it succeeded in starting the server."
  (unless *server-handler*
    (db:db-connect)
    (setf *server-handler*
          (clack:clackup *app*
                         :port *server-port*))
    t))
#+end_src

** Encerrando o servidor

Quando esta função é chamada, caso o servidor esteja ativo, o servidor
~clack~ será interrompido e o /handle/ assumirá o valor ~NIL~. Finalmente, a
aplicação se desconectará do banco de dados, retornando, finalmente, o
símbolo ~T~ no encerramento.

#+begin_src lisp
(defun stop-server ()
  "Stops the REST server if it is running.

Returns T if it succeeded in stopping the server."
  (when *server-handler*
    (clack:stop *server-handler*)
    (setf *server-handler* nil)
    (db:db-disconnect)
    t))
#+end_src

* Rotas
:PROPERTIES:
:header-args:lisp: :tangle src/routes.lisp
:END:

#+begin_src lisp
(in-package #:rest-server)
#+end_src

O arquivo =src/routes.lisp= engloba rotas da aplicação, sendo a porta de
entrada e saída do servidor para com o /frontend/.

A   aplicação  responde   com   seu  ponto   de   entrada  padrão   em
~localhost:9003~.

** Relação de rotas

Esta é a relação de métodos e rotas da aplicação, bem como as entradas
e  saídas esperadas  mediante  sucesso. Absolutamente  todas as  rotas
recebem e enviam JSON em forma de /string/.

# TODO: Mudar descrição de autenticação
Todas as rotas  requerem um Bearer Token de autenticação adicionado
ao /cabeçalho/  da requisição,  sob a  chave ~authentication~.  Este token
deve ser  um JSON Web Token,  que será obtido como  resposta durante a
autenticação.

A  única  requisição que  foge  a  esta regra  é  ~POST  /login~, que  é
responsável  por   gerar  o  JWT   a  ser  utilizado   em  requisições
subsequentes.

|--------+------------------+-----------------------------------+------------------------------------|
| <9>    | <16>             | <16>                              | <16>                               |
| Método | Rota             | Entrada                           | Saída                              |
|--------+------------------+-----------------------------------+------------------------------------|
| POST   | ~/login~           | E-mail e senha do usuário         | JSON Web Token de autenticação     |
| GET    | ~/users~           | -                                 | Lista de usuários.                 |
| GET    | ~/users/:id~       | -                                 | Dados de um usuário.               |
| GET    | ~/activ~           | -                                 | Lista de atividades.               |
| GET    | ~/activ/:id~       | -                                 | Detalhes de uma atividade.         |
| GET    | ~/users/:id/activ~ | -                                 | Lista de atividades de um usuário. |
| POST   | ~/users~           | Dados de um usuário.              | Mensagem de OK.                    |
| POST   | ~/activ~           | Dados de criação de uma atividade | Mensagem de OK.                    |
| DELETE | ~/users/:id~       | -                                 | Mensagem de OK.                    |
| DELETE | ~/activ/:id~       | -                                 | Mensagem de OK.                    |
|--------+------------------+-----------------------------------+------------------------------------|

Estas rotas  serão estabelecidas através  do system Ningle.  Para mais
informações, consulte [[https://github.com/fukamachi/ningle][este repositório]].

# TODO: Implementar rotas faltantes.

** Listagem de usuários

Ningle  possibilita  que  criemos  uma definição  de  rota  para  cada
caso. Primeiramente, definimos uma rota para requisição =GET= em =/users=,
que retorna todos os usuários cadastrados.

#+begin_src lisp
(setf (route *app* "/users" :method :GET)
      (lambda (params)
        (declare (ignore params))
        (db:control-index :user)))
#+end_src

Finalmente,  estabelecemos   uma  rota   para  a  requisição   =GET=  em
~/users/:id~, onde  ~:id~ representa  um parâmetro  esperado na  rota, que
estará na variável ~params~.

Caso a  ID do usuário em  questão seja inválida, retornamos  um objeto
JSON com  um único  campo de  mensagem, informando  que aquela  ID não
existe no banco de dados, e sob um código HTTP 404 (não encontrado).


#+begin_src lisp
(setf (route *app* "/users/:id" :method :GET)
      (lambda (params)
        (db:control-show :user params)))
#+end_src

#+RESULTS:
: #<FUNCTION (LAMBDA (PARAMS)) {53352AEB}>

** Registrar usuário

Abaixo,  definimos a  rota  para  registro do  usuário.  Veja que  não
tratamos  as  regras  de  negócio  aqui;  estas  ficarão  a  cargo  do
controlador do usuário.

#+begin_src lisp
(setf (route *app* "/users" :method :POST)
      (lambda (params)
        (declare (ignore params))
        (db:control-store :user)))
#+end_src

#+RESULTS:
: #<FUNCTION (LAMBDA (PARAMS)) {5335B62B}>

** Autenticar usuário

Esta rota  realiza o  login para um  usuário, dado o  seu email  e sua
senha, e  deve responder com algumas  informações e um token  JWT para
operações subsequentes, caso haja sucesso.

As regras de negócio são tratadas no controlador de sessão.

#+begin_src lisp
(setf (route *app* "/login" :method :POST)
      (lambda (params)
        (declare (ignore params))
        (db:control-store :session)))
#+end_src

* Banco de dados

Configuraremos  algumas   opções  relacionadas   ao  banco   de  dados
agora. Começaremos gerando um contêiner local para acesso aos dados, e
utilizaremos  Docker  para  gerenciá-lo;  em  seguida,  trataremos  da
conexão, e então de modelos e controladores.

As operações  relacionadas à  conexão e ao  gerenciamento do  banco de
dados, uma vez criado, foi consultada na documentação do pacote ~mito~ e
no [[https://lispcookbook.github.io/cl-cookbook/databases.html][The Common Lisp Cookbook]].

** Usando PostgreSQL pelo Docker

Usaremos Docker para  criar um banco de dados  com PostgreSQL, chamado
=cl-rest=, com uma senha =docker=. Redirecionaremos a porta padrão =5432= do
contêiner para a máquina, e faremos a imagem a partir de PostgreSQL 11.

#+begin_src bash :eval no
docker run --name cl-rest \
       -e POSTGRES_PASSWORD=docker \
       -p 5432:5432 \
       -d postgres:11
#+end_src

#+RESULTS:
: d6cdbe8e7697835291043db255d84d1dd69a44dcaa46ce207df38eebdecda56c

Uma dica  útil é que podemos  ver quais contêineres estão  em execução
usando o comando:

#+begin_src bash :eval no
docker ps
#+end_src

...ou ver todos os contêineres da máquina com:

#+begin_src bash :eval no
docker ps -a
#+end_src

Podemos  também  utilizar  os  comandos  a  seguir  para  controlar  o
contêiner.

#+begin_src bash :eval no
docker start cl-rest # Inicia o contêiner
docker stop cl-rest  # Mata o contêiner
docker logs cl-rest  # Mostra os logs do contêiner
#+end_src

** Criando um banco de dados

Faremos, agora, a  operação manual de criar um banco  de dados no SGBD
PostgreSQL. Para tanto, recomendo utilizar o Postbird.

Conecte-se  ao PostgreSQL  através do  Postbird, e  crie uma  /database/
chamada =cl-rest=. As  tabelas e demais elementos  serão criados através
de código, principalmente  usando o pacote ~mito~, uma  solução ORM para
Common Lisp.

** Conexão com o banco de dados
:PROPERTIES:
:header-args:lisp: :tangle src/db.lisp
:END:

#+begin_src lisp
(in-package #:rest-server.db)
#+end_src

Vamos definir  algumas funções que conectam  o ~mito~ ao nosso  banco de
dados recém-criado.

*** Definições globais

Vamos explicitar alguns dados de conexão com o PostgreSQL. Idealmente,
armazenaríamos estas informações em outro lugar, para evitar problemas
de segurança.

#+begin_src lisp
(defparameter *db-username* "postgres"
  "Username for accessing the database.")
(defparameter *db-dbname*   "cl-rest"
  "Name of the database in the RDBMS.")
(defparameter *db-pass*     "docker"
  "Password of the database in the RDBMS.
Consider replacing this by an environment variable.")
#+end_src

*** Iniciando a conexão

A função  a seguir pode ser  chamada para iniciar uma  conexão entre o
~mito~ e  o PostgreSQL. Aqui, fornecemos  o usuário, o nome  do banco de
dados e a senha do serviço.

#+begin_src lisp
(defun db-connect ()
  "Starts a connection with the database."
  (mito:connect-toplevel
   :postgres
   :username      *db-username*
   :database-name *db-dbname*
   :password      *db-pass*))
#+end_src

A   conexão   do   ~mito~   é   globalmente   acessível   no   parâmetro
~mito:*connection*~.

*** Encerrando a conexão

A função a seguir invoca diretamente o ~mito~ para que encerre a conexão
com o banco de dados, caso esteja ativa.

#+begin_src lisp
(defun db-disconnect ()
  "Disconnects from the database."
  (mito:disconnect-toplevel))
#+end_src

** Migrações
:PROPERTIES:
:header-args:lisp: :tangle src/db.lisp
:END:

Realizar    migrações    com    o    ~mito~    é    algo    extremamente
simples.

Programaremos  uma solução  para  migrações via  código  direto, e  em
seguida, configuraremos o projeto para  que estas migrações possam ser
feitas através do console.

*** Executando as migrações em código

Primeiramente, definiremos  uma  lista de  todas as  tabelas
existentes, cada qual  correspondente a um /model/ que  também faz parte
do pacote atual, mas é definida em seu respectivo arquivo.

#+begin_src lisp
(defparameter *db-tables* '(user)
  "List of tables which should be checked on migration.")
#+end_src

A função  a seguir  mapeia a  função ~mito:ensure-table-exists~  sobre a
lista de tabelas esperada, garantindo que todas as tabelas existam.

#+begin_src lisp
(defun db-ensure-tables ()
  "Ensures that the tables exist."
  (mapcar #'mito:ensure-table-exists *db-tables*))
#+end_src

Já a função a seguir realiza as /migrações/ propriamente ditas, mapeando
~mito:migrate-table~ sobre todas as tabelas da lista. Assim, caso alguma
definição das classes  no ORM tenha sido alterada,  ~mito~ realizará uma
operação de ~ALTER TABLE~ necessária.

#+begin_src lisp
(defun db-migrate-tables ()
  "Performs migrations on existing tables, adjusting
them if their definitions were changed."
  (mapcar #'mito:migrate-table *db-tables*))
#+end_src

Você poderá verificar  o código SQL a ser executado  antes da migração
através da função ~mito:migration-expressions~,  seguido do símbolo para
a tabela criada.  A função auxiliar a seguir mapeia  esta função sobre
todas as  tabelas e  coleta os códigos  de migração  pretendidos, para
cada tabela que necessita de migração.

#+begin_src lisp
(defun db-migration-expressions ()
  "Retrieves migration expressions for the tables
which should be migrated.

Returns an alist containing the migration expressions
for the tables which demand migration. If no table
demands any migration, returns NIL."
  (loop for table in *db-tables*
     for expr = (mito:migration-expressions table)
     when expr
     collect (list table expr)))
#+end_src

A função auxiliar  a seguir toma as expressões SQL  necessárias para a
definição das tabelas 

#+begin_src lisp
(defun db-table-definitions ()
  "Retrieves the table definition expressions for
all tables."
  (loop for table in *db-tables*
     for expr = (mito:table-definition table)
     collect (list table expr)))
#+end_src

Finalmente, a função a seguir apenas executa as funções de garantia de
existência e migração automaticamente.

#+begin_src lisp
(defun db-gen-tables ()
  "Generates the application's tables for the first
time. This ensures that they exist and also migrates
them if necessary."
  (db-ensure-tables)
  (db-migrate-tables))
#+end_src

**** Verificando o SQL gerado a cada consulta

Para  imprimir  o SQL  de  cada  consulta  no  REPL, use  o  parâmetro
~mito:*mito-logger-stream*~. Por exemplo:

#+begin_src lisp :tangle no :results output :exports both :eval no
(setf mito:*mito-logger-stream* t)
(mito:find-dao 'user :mail "fulano@exemplo.com")
#+end_src

#+RESULTS:
: ;; SELECT * FROM "user" WHERE ("mail" = $1) LIMIT 1 ("fulano@exemplo.com") [1 row] (2ms) | SWANK::CALL-WITH-RETRY-RESTART

Para voltar ao normal:

#+begin_src lisp :tangle no :eval no
(setf mito:*mito-logger-stream* nil)
#+end_src

#+RESULTS:
: NIL

*** Executando as migrações pelo console

Antes de  gerarmos as tabelas  de fato,  podemos executar o  ~mito~ pelo
console  para que  este gere  arquivos  ~.sql~ das  migrações, com  seus
respectivos timestamps.

Esta opção  é muito útil  caso você  queira garantir que  suas tabelas
sejam versionadas,  e que  o versionamento seja  feito em  seu próprio
arquivo de código SQL.

Para tanto:

1. Navegue até a pasta raiz do projeto;
2. Crie um  diretório chamado ~mito~. Usaremos  este diretório para
   armazenar todos os arquivos ~.sql~ criados pelo ~mito~ no console.

#+begin_src bash :eval no :tangle no
cd /path/to/rest-server-example
mkdir mito
#+end_src

Finalmente,  execute  o comando  a  seguir.  Veja  que ele  utiliza  a
instalação  do  Quicklisp  pelo  Qlot para  criar  as  migrações  como
necessário:

#+begin_src bash :eval no :tangle no
qlot exec mito generate-migrations -t postgres \
     -u postgres -p docker -P 5432 -d cl-rest \
     -s rest-server-example -D ./mito
#+end_src

Destrinchando este comando, temos os seguintes argumentos:

- =-t postgres=: Anuncia que o tipo do  banco de dados a ser utilizado é
  PostgreSQL;
- =-u postgres=:  Anuncia o  nome do  usuário do  banco de  dados. Neste
  caso, sendo ~postgres~;
- =-p docker= Anuncia a senha de acesso do usuário;
- =-P 5432=: Anuncia a porta na qual o banco de dados está operando;
- =-d cl-rest=: Anuncia o nome do banco de dados (~cl-rest~);
- =-D ./mito=: Anuncia o diretório onde as migrações serão armazenadas.

Lembremos sempre que informações sensíveis (usuário e senha do banco
de dados, por  exemplo) são melhor armazenados em um  local de difícil
acesso para o público em geral.

O argumento =-s rest-server-example= deixa  bem claro que vamos carregar
o /system/ do  projeto atual (homônimo ao informado).  Dessa forma, ~mito~
varre  todos  os  pacotes  do  sistema,  em  busca  de  definições  de
tabelas. Ao encontrá-las, ele gera os arquivos SQL necessários para as
mesmas.

Por  conveniência, à  medida  que  o projeto  evoluir,  vou manter  as
migrações geradas neste repositório, constatando as mudanças que foram
efetuadas.

Para avaliar o estado das migrações em questão, podemos usar novamente
o ~mito~, desta vez sem necessidade do respaldo do Qlot:

#+begin_src bash :tangle no :cache yes :exports both :results verbatim :eval no
mito migration-status -t postgres \
     -u postgres -p docker -P 5432 -d cl-rest \
     -D ./mito
#+end_src

#+RESULTS[794b2433a8feb8a1e024e55a54c1bd83190f1140]:
: 
:  Status   Migration ID
: --------------------------
:   down    20200416161815

Agora, podemos finalmente migrar o banco de dados:

#+begin_src bash :tangle no :cache yes :exports both :results verbatim
mito migrate -t postgres \
     -u postgres -p docker -P 5432 -d cl-rest \
     -D ./mito
#+end_src

#+RESULTS[9e53747730c5174881ffd71a0eacf860447b3fba]:
#+begin_example

Applying './mito/schema.sql'...
-> CREATE TABLE "user" (
    "id" BIGSERIAL NOT NULL PRIMARY KEY,
    "name" VARCHAR(80) NOT NULL,
    "birthdate" TIMESTAMPTZ NOT NULL,
    "address" VARCHAR(255) NOT NULL,
    "mail" VARCHAR(64) NOT NULL,
    "pass" VARCHAR(64) NOT NULL,
    "created_at" TIMESTAMPTZ,
    "updated_at" TIMESTAMPTZ
);
-> CREATE UNIQUE INDEX "unique_user_mail" ON "user" ("mail");
-> CREATE TABLE IF NOT EXISTS "schema_migrations" (
    "version" VARCHAR(255) PRIMARY KEY,
    "applied_at" TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP
);
Successfully updated to the version "20200416161815".
#+end_example

**** Scripts para migração

Os comandos anteriores são longos, portanto vamos criar alguns scripts
para  migração em  um diretório  chamado ~scripts~.  Crie-os na  raiz do
projeto:

#+begin_src bash :eval no :tangle no
cd /path/to/rest-server-example
mkdir scripts
#+end_src

Desta vez,  é interessante que  façamos scripts Bash para  executar os
comandos.

Lembremos mais  uma vez que  as informações sensíveis  utilizadas aqui
deveriam  ser  armazenadas em  outro  lugar,  por segurança,  e  então
utilizadas pelos scripts em si.

~scripts/gen-migrations.sh~:

#+begin_src bash :tangle scripts/gen-migrations.sh :eval no
#!/bin/bash
qlot exec mito generate-migrations -t postgres \
     -u postgres -p docker -P 5432 -d cl-rest \
     -s rest-server-example -D ./mito
#+end_src

~scripts/migration-status.sh~:

#+begin_src bash :tangle scripts/migration-status.sh :eval no
#!/bin/bash
mito migration-status -t postgres \
     -u postgres -p docker -P 5432 -d cl-rest \
     -D ./mito
#+end_src

~scripts/migrate.sh~:

#+begin_src bash :tangle scripts/migrate.sh :eval no
#!/bin/bash
mito migrate -t postgres \
     -u postgres -p docker -P 5432 -d cl-rest \
     -D ./mito
#+end_src

O último passo é permitir  que estes arquivos sejam executáveis. Basta
alterar suas permissões com:

#+begin_src bash :eval yes
chmod +x scripts/*.sh
#+end_src

#+RESULTS:

** Seeds
:PROPERTIES:
:header-args:lisp: :tangle src/db.lisp
:END:

A  função a  seguir popula  o banco  de dados  com alguns  exemplos de
dados. Atualmente, apenas dois usuários são inseridos.

#+begin_src lisp
(defun db-seed ()
  "Populates the database with test information."
  (labels ((seed-users (seed)
             (loop for user in seed
                do (mito:insert-dao
                    (make-instance
                     'user
                     :name (util:agetf :name user)
                     :birthdate (util:agetf :birthdate user)
                     :address (util:agetf :address user)
                     :mail (util:agetf :mail user)
                     :password (util:agetf :password user))))))
    (seed-users '(((:name      . "Fulano da Silva")
                   (:birthdate . "1990-01-01 12:00:00-03")
                   (:address   . "Rua dos Bobos, 0")
                   (:mail      . "fulano@exemplo.com")
                   (:password  . "123456"))
                  ((:name      . "Ciclano da Silva")
                   (:birthdate . "1990-01-01 12:00:00-03")
                   (:address   . "Rua dos Bobos, 1")
                   (:mail      . "ciclano@exemplo.com")
                   (:password  . "123456"))))))
#+end_src

** Modelos

As  próximas  definições  tratam  de /modelos/  da  aplicação,  que  são
correspondentes também  a tabelas da  mesma. Portanto, cada  um destes
modelos encontra-se em um arquivo próprio.

*** Usuário
:PROPERTIES:
:header-args:lisp: :tangle src/models/user.lisp
:END:

#+begin_src lisp
(in-package #:rest-server.db)
#+end_src

Aqui definimos  os campos para  um usuário  do sistema.  Os  campos da
tabela do usuário estão listados a seguir:

|---------------+-------------+----------------------------|
| Nome          | Tipo        | Observações                |
|---------------+-------------+----------------------------|
| id            | BIGSERIAL   | Automático, chave primária |
| name          | VARCHAR 80  |                            |
| birthdate     | TIMESTAMPTZ |                            |
| address       | VARCHAR 255 |                            |
| mail          | VARCHAR 64  | Índice único               |
| password_hash | CHAR 64     | Automático (mito-auth)     |
| password_salt | BINARY 20   | Automático (mito-auth)     |
| created_at    | TIMESTAMPTZ | Automático                 |
| updated_at    | TIMESTAMPTZ | Automático                 |
|---------------+-------------+----------------------------|

#+begin_src lisp
(deftable user (has-secure-password)
  ((name :col-type (:varchar 80)
         :initarg :name
         :accessor user-name)
   (birthdate :col-type :timestamptz
              :initarg :birthdate
              :accessor user-birthdate)
   (address :col-type (:varchar 255)
            :initarg :address
            :accessor user-address)
   (mail :col-type (:varchar 64)
         :initarg :mail
         :accessor user-mail))
  (:unique-keys mail)
  (:documentation
   "Represents the `user` table on database."))
#+end_src

#+RESULTS:
: #<DAO-TABLE-CLASS REST-SERVER.DB:USER>

É interessante  lembrar que  uma tabela  do ~mito~ nada  mais é  que uma
classe, cujo campo ~:metaclass~ equivale a ~mito:dao-table-class~.

** Interface de controladores

As próximas definições  tratam dos /controllers/ da  aplicação, ou seja,
elementos  que  reforçam  as  regras  de  negócio  da  aplicação.  Por
enquanto, definiremos operações genéricas  que devem ser implementadas
por   cada  controlador,   ou   seja,  uma   interface  inicial   para
controladores.

*** Operações genéricas
:PROPERTIES:
:header-args:lisp: :tangle src/db.lisp
:END:

Primeiramente, definiremos algumas  operações genéricas que entendemos
que quaisquer modelos necessitem definir.

**** Index

O método  /index/ está  diretamente relacionado à  listagem de  todas as
entidades de uma tabela em específico. Em outras palavras, este método
deve retornar uma resposta contendo toda  a lista de entidades para um
determinado modelo, por exemplo.

A requisição recebida  também poderá ter alguma  informação relativa a
paginação, diminuindo a carga do servidor.

#+begin_src lisp
(defgeneric control-index (type-key &optional params)
  (:documentation "Specifies an operation of listing all entities
for a specific table or business rule. May require some
parameters related to pagination to reduce server load."))
#+end_src

**** Show

O método /show/ é  parecido com o /index/. Todavia, ao  invés de lidar com
todas as  entidades em questão,  existe apenas para mostrar  uma única
entidade,  que   deverá  ter   seu  parâmetro  informado   através  da
requisição.

#+begin_src lisp
(defgeneric control-show (type-key &optional params)
  (:documentation "Specifies an operation of listing a single
entity for a specific table or business rule."))
#+end_src

**** Store

O método /store/ está diretamente relacionado à criação de uma entidade,
no sentido de sua persistência. Por  exemplo, o cadastro de um usuário
deve ser  feito pela  ação /store/  de seu  controlador, que  entrará em
contato com  seu respectivo /model/  e avaliará os dados  recebidos pela
requisição para que isto seja feito.

Este método também  não precisa ser apenas  relacionado a persistência
de dados. Por exemplo, em um controlador de sessão, podemos utilizar o
método /store/ para realizar a autenticação do usuário.

#+begin_src lisp
(defgeneric control-store (type-key &optional params)
  (:documentation "Specifies an operation for creating a new
entity or performing a creation operation for a
specific table or business rule."))
#+end_src

**** Update

O  método  /update/  é  similar  ao  /store/,  porém  está  relacionado  à
modificação  de  uma  entidade  já  existente em  algum  lugar,  ou  à
modificação de alguma regra de negócio já em vigor.

#+begin_src lisp
(defgeneric control-update (type-key &optional params)
  (:documentation "Specifies an operation for changing a specific
entity or performing an update of an entity from a
table or business rule."))
#+end_src

**** Delete

O método  /delete/ lembra vagamente o  /update/ no sentido de  que realiza
uma  alteração  em uma  entidade  já  existente. Este  método,  porém,
efetivamente *remove* tal entidade, ao invés de modificá-la.

#+begin_src lisp
(defgeneric control-delete (type-key &optional params)
  (:documentation "Specifies an operation for removing a specific
entity from a table or from a business rule."))
#+end_src

* Autenticação de Usuário
:PROPERTIES:
:header-args:lisp: :tangle src/jwt.lisp
:END:

#+begin_src lisp
(in-package #:rest-server.db)
#+end_src

Para  a   maioria  das   operações  especificadas  por   métodos  para
controladores, precisaremos garantir que as mesmas sejam feitas por um
usuário que esteja autenticado no sistema.

Podemos garantir isto  através de uma autenticação  /stateless/ com JSON
Web Tokens, que consistem de dados digitalmente assinados com um tempo
determinado de vida. Após este tempo  ser esgotado, o token expira e o
usuário terá que fazer login novamente.

Mais informações sobre JSON Web Tokens podem ser obtidas em [[https://jwt.io][jwt.io]]. As
demais operações descrevem o que será feito no arquivo ~src/jwt.lisp~.

** Gerador de JSON Web Token

Começaremos criando algumas ferramentas para  a geração de um JSON Web
Token. Para  tanto, utilizaremos o  /system/ ~JOSE~, que nos  auxiliará na
assinatura dos dados e consequente geração e validação do JWT.

*** Parâmetros do Token

O primeiro passo  é estabelecer algumas informações  relevantes para a
aplicação. A maior parte destas informações deveria ser declarada fora
do código  do programa, mas  deixaremos o mesmo aqui  por conveniência
didática.

Estabelecemos  o  método  de   hashing  utilizado  na  assinatura  dos
dados. Utilizaremos o método HS256.

#+begin_src lisp
(defparameter *jwt-method* :hs256)
#+end_src

O próximo  passo é gerar  uma chave única  para a aplicação  que serve
como /salt/ durante o processo de assinatura. Esta chave pode e deve ser
armazenada  em algum  lugar  externo à  aplicação,  como variáveis  de
ambiente.

Usamos  o /system/  ~Ironclad~ para  converter o  /salt/ de  seu formato  de
string de hexadecimais para vetor de /bytes/.

#+begin_src lisp
(defparameter *jwt-salt*
  (ironclad:hex-string-to-byte-array
   "04f79366645b309340cf5c8c308e780c6db9287d9bdc7664d96649"))
#+end_src

O /salt/ em si pode ser gerado de várias formas.

Uma delas é diretamente através do ~Ironclad~: geramos um /salt/ aleatório
de 27 /bytes/,  que será disposto em um vetor,  e em seguida codificamos
estes /bytes/ para uma string hexadecimal. Veja um exemplo deste código,
usando a notação de setas de ~cl-arrows~:

#+begin_src lisp :tangle no
(->> (ironclad:make-random-salt 27)
     ironclad:byte-array-to-hex-string)
#+end_src

Finalmente, determinamos o tempo padrão de expiração de um token JWT.

O tempo de expiração padrão  corresponde a sete dias corridos, podendo
este valor ser alterado no futuro de acordo com a necessidade.

#+begin_src lisp
(defparameter *jwt-expires-in* '((:days . 7)))
#+end_src

*** Data de criação

O /claim/ ~iat~ é um campo reservado segundo a especificação no /payload/ do
JWT (ou seja, nos "dados assinados"  do token). Este campo determina a
data exata de quando o token em questão foi gerado.

O campo é um número inteiro  não-negativo, que informa a data exata de
criação do JWT,  em milissegundos, contando a partir da  data de 1º de
janeiro de 1970, 00:00, GMT+0.

Esta data não corresponde à contagem interna de Common Lisp, que conta
em /segundos/  a partir  de 1º  de janeiro de  1900, 00:00,  GMT+0. Esta
conversão para milissegundos e para uma contagem a partir de nova data
é feita para  garantir conformidade com outras bibliotecas  de JWT, em
particular ~jsonwebtoken~ de JavaScript.

#+begin_src lisp
(defun gen-jwt-creation-time ()
  "Retrieve current time as time difference between now
and January 1st, 1970, in miliseconds. The date is
retrieved in seconds and then multiplied by 1000 for
JavaScript conformance."
  (-> (get-universal-time)
      (- (encode-universal-time 0 0 0 1 1 1970 0))
      (* 1000)))
#+end_src

#+RESULTS:
: GEN-JWT-CREATION-TIME

Adicionalmente,  podemos  definir  uma  função que  formata  uma  data
qualquer que  tenha sido gerada  como números inteiros para  JWT. Isto
será feito apenas com intuito de /debug/.

#+begin_src lisp
(defun dbg-format-jwt-time (time)
  "Takes a time generated for any claim of a JWT and
formats it into a string, for debug purposes."
  (let ((time (-> (encode-universal-time 0 0 0 1 1 1970 0)
                  (* 1000)
                  (+ time))))
    (multiple-value-bind
          (sec min hour date month year day daylight-p zone)
        (decode-universal-time (floor time 1000))
      (declare (ignore day daylight-p))
      (format nil "~2,'0d/~2,'0d/~4,'0d ~2,'0d:~2,'0d:~2,'0d+~d"
              month date year hour min sec zone))))
#+end_src

#+RESULTS:
: DBG-FORMAT-JWT-TIME

*** Data de expiração

Assim como ~iat~, ~exp~ é um  /claim/ reservado, que representa a data exata
de *expiração* do token.

O cálculo da data de expiração é  feito de forma relativa, a partir de
uma data de criação (~iat~) informada  via parâmetro. Por exemplo, se os
parâmetros para dedução de um  ~exp~ forem uma alist como esta...

#+begin_src lisp :tangle no
'((:years 1) (:months 2) (:days 7))
#+end_src

...a  função deduzirá  uma data  futura, que  corresponderá ao  espaço
exato de  um ano, dois  meses e  sete dias após  a data de  criação do
token informada.

Estas datas são calculadas com base em valores comerciais, portanto um
ano corresponde  a 365  dias, um  mês corresponde a  30 dias,  e assim
sucessivamente.

#+begin_src lisp
(defun gen-jwt-expiration-time (creation-time params)
  "Takes a creation time in miliseconds specially generated
for JWT and returns its expiration date. The parameters must
be an alist where each pair specifies a time period and the
associated value must be a number."
  (loop for pair in params
     sum (* (cdr pair) ; lets hope sbcl constantfolds this
            (case (car pair)
              ((:years)   (* 365 24 60 60 1000))
              ((:months)  (* 30 24 60 60 1000))
              ((:days)    (* 24 60 60 1000))
              ((:hours)   (* 60 60 1000))
              ((:minutes) (* 60 1000))
              ((:seconds) 1000)
              (t 1)))
     into extra-ms
     finally (return (+ creation-time extra-ms))))
#+end_src

#+RESULTS:
: GEN-JWT-EXPIRATION-TIME

Em  geral,   o  tempo   de  expiração   será  ditado   pelo  parâmetro
~*JWT-EXPIRES-IN*~, definido anteriormente.

*** Função para resposta a requisição de sessão

Esta função simples  termina a operação de criação de  um JWT, gerando
uma alist  que servirá de resposta  para uma tentativa com  sucesso de
autenticação no sistema. Será retornada  uma alist contendo o tempo de
criação e de expiração do  token, mais alguns dados extras informados,
e também um campo com o token em si.

Todos os dados retornados na  alist (exceto o token) serão devidamente
assinados e retransmitidos de forma  redundante no campo que carrega o
JWT.

#+begin_src lisp
(defun gen-session-data (extra-data)
  "Generates an alist containing a JWT with issue
time and expiration time, plus some extra data that
is also signed and inserted into the token itself."
  (let* ((creation-time (gen-jwt-creation-time))
         (expiry-time   (gen-jwt-expiration-time
                         creation-time
                         ,*jwt-expires-in*))
         (extra-data (append extra-data
                             `(("iat" . ,creation-time)
                               ("exp" . ,expiry-time)))))
    (append extra-data
            `(("token" .
                       ,(jose:encode *jwt-method*
                                     ,*jwt-salt*
                                     extra-data))))))
#+end_src

#+RESULTS:
: GEN-SESSION-DATA

** Verificação de JSON Web Token

# TODO:  Informar  que  o  token  deve  ser  fornecido  no  Header  da
# requisição, em forma de Bearer.


*** Verificação de token

#+begin_src lisp
(defun jwt-valid-p (token)
  (let* ((token-data
          (handler-case 
              (jose:decode *jwt-method*
                           ,*jwt-salt*
                           token)
            (jose/errors:jws-verification-error (e)
              (declare (ignore e))
              nil)))
         (iat (cdr (assoc "iat" token-data :test #'equal)))
         (exp (cdr (assoc "exp" token-data :test #'equal))))
    (if (not token-data)
        (values nil nil)
        (values
         (and (numberp iat)
              (numberp exp)
              (let ((diff (- exp iat))
                    (currt (gen-jwt-creation-time)))
                (not (minusp diff))
                (not (zerop diff))
                (< iat exp)
                (< iat currt)
                (> exp currt)))
         token-data))))
#+end_src

#+RESULTS:
: JWT-VALID-P

*** Verificação de payload genérico

#+begin_src lisp
(defun request-authorized-p (bearer-token)
  (let ((parts (split-sequence #\space bearer-token)))
    (and (= 2 (length parts))
         (string= (first parts) "Bearer")
         (multiple-value-bind (result token-data)
             (jwt-valid-p (second parts))
           (or (and result (values t token-data))
               (values nil nil))))))
#+end_src

*** Verificações de métodos de controladores

**** Verificação do Index

#+begin_src lisp
(defmethod control-index :around (type &optional params)
  (declare (ignore type params))
  (if (->> ningle:*request*
              lack.request:request-headers
              (gethash "authorization")
              request-authorized-p
              not)
      (util:http-response (401)
        "Authentication token is invalid.")
      (call-next-method)))
#+end_src

#+RESULTS:
: #<STANDARD-METHOD REST-SERVER.DB:CONTROL-INDEX :AROUND (T) {1001CB9EE3}>

**** Verificação do Show

#+begin_src lisp
(defmethod control-show :around (type &optional params)
  (declare (ignore type params))
  (if (->> ningle:*request*
              lack.request:request-headers
              (gethash "authorization")
              request-authorized-p
              not)
      (util:http-response (401)
        "Authentication token is invalid.")
      (call-next-method)))
#+end_src

#+RESULTS:
: #<STANDARD-METHOD REST-SERVER.DB:CONTROL-SHOW :AROUND (T) {100367EA83}>

**** Verificação do Store

#+begin_src lisp
(defmethod control-store :around (type &optional params)
  (declare (ignore params))
  (cond ((eql type :session)
         (call-next-method))
        ((->> ningle:*request*
              lack.request:request-headers
              (gethash "authorization")
              request-authorized-p
              not)
         (util:http-response (401)
           "Authentication token is invalid."))
        (t (call-next-method))))
#+end_src

#+RESULTS:
: #<STANDARD-METHOD REST-SERVER.DB:CONTROL-STORE :AROUND (T) {10054843A3}>

**** Verificação do Update

#+begin_src lisp
(defmethod control-update :around (type &optional params)
  (declare (ignore type params))
  (if (->> ningle:*request*
              lack.request:request-headers
              (gethash "authorization")
              request-authorized-p
              not)
      (util:http-response (401)
        "Authentication token is invalid.")
      (call-next-method)))
#+end_src

**** Verificação do Delete

#+begin_src lisp
(defmethod control-delete :around (type &optional params)
  (declare (ignore type params))
  (if (->> ningle:*request*
              lack.request:request-headers
              (gethash "authorization")
              request-authorized-p
              not)
      (util:http-response (401)
        "Authentication token is invalid.")
      (call-next-method)))
#+end_src

* Controladores

As próximas definições implementam controladores a partir da interface
previamente  definida.  Cada  controlador será  identificado  por  uma
palavra-chave  em  específico  (ex.   ~:user~  ou  ~:session~),  e  poderá
implementar parcial ou totalmente a interface para um controlador.

Cada controlador possui seu próprio arquivo de código-fonte.

** Controlador de Usuário
:PROPERTIES:
:header-args:lisp: :tangle src/controllers/user-controller.lisp
:END:

#+begin_src lisp
(in-package #:rest-server.db)
#+end_src

Os  métodos  definidos  a  seguir  dizem  respeito  ao  /controller/  de
Usuário.  Estes  métodos  são  diretamente  responsáveis  pelas  rotas
relacionadas a gerenciamento de usuários.

*** Index

O  método /index/  é capaz  de  mostrar todos  os usuários  do banco  de
dados. Estes usuários são retornados na  forma de um vetor de objetos,
em notação JSON.

# TODO: Exigir ou permitir paginação

#+begin_src lisp
(defmethod control-index ((type (eql :user)) &optional params)
  (declare (ignore params))
  (->> (mito:select-dao 'db:user)
       (mapcar #'util:dao->filtered-alist)
       json:encode-json-to-string))
#+end_src

#+RESULTS:
: #<STANDARD-METHOD REST-SERVER.DB:CONTROL-INDEX ((EQL :USER) T T) {10070E5043}>

*** Show

O método /show/ é  capaz de mostrar os dados de  um único usuário. Estes
dados são retornados  em forma de JSON. Caso o  usuário em questão não
exista, a requisição falhará sob um erro HTTP 404, informando que o ID
requisitado não existe.

Como o  ID do  usuário é  informado através dos  parâmetros da  URL de
acesso,  recebemos  estes  parâmetros   por  argumento,  ao  invés  da
requisição em si.

#+begin_src lisp
(defmethod control-show ((type (eql :user)) &optional params)
  (let ((user (mito:find-dao
               'db:user
               :id (util:agetf :id params))))
    (if (null user)
        (util:http-response (404)
          "Unknown user ID ~a"
          (util:agetf :id params))
        (util:dao->json user))))
#+end_src

*** Store

O método /store/ cadastra um novo usuário no banco de dados.

O  corpo da  requisição espera  pelos campos  necessários para  que um
usuário seja registrado no sistema.

Estes campos são automaticamente deduzidos a partir da classe ~db:user~,
que representa  a tabela ~user~, e  portanto podem mudar sem  prejuízo à
verificação dos campos necessários.

Este  método  pode retornar  códigos  HTTP  ~400~  caso os  dados  sejam
insuficientes,  ou caso  o usuário  já exista  no banco  de dados.  Do
contrário, é  retornada uma  mensagem de sucesso  em JSON,  cujo campo
~"message"~ contém a string ~"OK"~.

#+begin_src lisp
(defmethod control-store ((type (eql :user)) &optional params)
  (declare (ignore params))
  (let ((payload (util:get-payload ningle:*request*)))
    (if (not (util:post-valid-data-p 'db:user payload
                                     :has-password t))
        (util:http-response (400)
          "Malformed user data")
        (handler-case
            (macrolet ((get-field (field)
                         `(util:agetf ,field payload)))
              (mito:create-dao
               'user
               :name (get-field :name)
               :birthdate (get-field :birthdate)
               :address (get-field :address)
               :mail (get-field :mail)
               :password (get-field :password))
              (util:http-response ())) ; 200 OK
          (dbi.error:dbi-database-error (e)
            (declare (ignore e))
            (util:http-response (400)
              "User already exists"))))))
#+end_src

#+RESULTS:
: #<STANDARD-METHOD REST-SERVER.DB:CONTROL-STORE ((EQL :USER)) {1002B675C3}>

** Controlador de Sessão
:PROPERTIES:
:header-args:lisp: :tangle src/controllers/session-controller.lisp
:END:

#+begin_src lisp
(in-package #:rest-server.db)
#+end_src

Os  métodos  definidos  a  seguir  dizem  respeito  ao  /controller/  de
Sessão.  Sessões não  existem  enquanto entidades  em  nosso banco  de
dados,  sendo gerenciadas  principalmente por  tokens JWT  que expiram
após algum tempo.

*** Store

O método /store/ cria uma nova sessão para um usuário informado no corpo
da requisição.

O  corpo  deverá  informar  os   elementos  ~mail~  e  ~password~  para  o
usuário. Caso estes elementos não sejam informados, será retornada uma
resposta  HTTP 400,  dizendo que  as  informações de  login não  estão
completas.

Caso o usuário  não possa ser encontrado por seu  ~mail~, será retornada
uma  nova  resposta  HTTP  404,  informando  que  o  usuário  não  foi
encontrado ou não existe.

# TODO: Gerar token JWT e documentar o retorno

#+begin_src lisp
(defmethod control-store ((type (eql :session)) &optional params)
  (declare (ignore params))
  (let* ((payload (util:get-payload ningle:*request*))
         (mail (util:agetf :mail payload))
         (pass (util:agetf :password payload)))
    (if (or (null mail) (null pass))
        (util:http-response (400)
          "Malformed login data")
        (let* ((dao (mito:find-dao 'db:user :mail mail))
               (alist (if dao (util:dao->alist dao) nil)))
          (cond ((null dao)
                 (util:http-response (404)
                   "Unknown user"))
                ((mito-auth:auth dao pass)
                 (util:http-response ()
                   (gen-session-data
                     `(("id" . ,(util:agetf :id alist))
                       ("mail" . ,mail)))))
                (t (util:http-response (403)
                     "Wrong password")))))))
#+end_src

#+RESULTS:
: #<STANDARD-METHOD REST-SERVER.DB:CONTROL-STORE ((EQL :SESSION)) {1008DE9523}>

* Utilitários
:PROPERTIES:
:header-args:lisp: :tangle src/util.lisp
:END:

#+begin_src lisp
(in-package #:rest-server.util)
#+end_src

As funções e macros a seguir  são gerais para a aplicação, podendo ser
utilizados em qualquer lugar. Geralmente são aqui deixados para evitar
poluição no código.

** Obtendo elemento de uma alist ao usar macros

Este macro  tenta obter  o valor  associado a uma  certa chave  em uma
lista  de  atributos  (alist),  caso  exista.  Se  não  existir,  será
retornado ~NIL~.

Este macro  presume que a alist  seja composta de pares  criados com a
função ~CONS~, onde o ~CDR~ não seja uma lista.

#+begin_src lisp
(defmacro agetf (key alist)
  "Retrieves a value from ALIST which is under a
certain KEY.

Returns the associated value or NIL if not found."
  `(cdr (assoc ,key ,alist)))
#+end_src

** Preparando uma resposta em JSON do Ningle

Este macro,  se usado  adequadamente (dentro de  uma rota  do Ningle),
prepara a rota atual para uma resposta HTTP. Por padrão, determina uma
resposta de sucesso (código 200) com um corpo JSON.

#+begin_src lisp
(defmacro route-prepare-response (response-object
                                  &optional
                                    (http-code 200)
                                    (type "application/json"))
  `(progn
     (setf (lack.response:response-headers ,response-object)
           (append
            (lack.response:response-headers ,response-object)
            (list :content-type ,type)))
     (setf (lack.response:response-status ,response-object)
           ,http-code)))
#+end_src

#+RESULTS:
: ROUTE-PREPARE-RESPONSE

O macro a seguir é preparado para ser utilizado diretamente nas rotas,
como uma  forma sucinta  de estabelecer  uma resposta  formatada. Esta
resposta será gerada /ad-hoc/ e inserida no corpo do JSON, com uma chave
~"message"~. Por padrão, retorna uma mensagem de sucesso (código 200).

#+begin_src lisp
(defmacro http-response ((&optional (http-code 200)
                          res)
                         &body body)
  `(progn (route-prepare-response ,(or res 'ningle:*response*)
                                  ,http-code
                                  "application/json")
          (json:encode-json-to-string
           ,(cond ((null body)
                   `(list '(:message . "OK")))
                  ((consp (first body))
                   (first body)) ; todo: subformats
                  ((and (stringp (first body))
                        (= (length body) 1))
                   `(list '(:message . ,(first body))))
                  (t
                   `(list
                     (cons :message
                           (format nil ,@body))))))))
#+end_src

#+RESULTS:
: HTTP-RESPONSE

** Convertendo símbolos para keywords

Esta função converte um certo  símbolo genérico para uma /keyword/. Esta
operação  é  muito  útil  quando  estamos  tratando  de  símbolos  que
pertencem  a outros  pacotes, pois  /keywords/ sempre  pertencem ao  seu
próprio pacote.

#+begin_src lisp
(defun symbol->keyword (symbol)
  "Transforms a specific SYMBOL into a keyword."
  (unless (symbolp symbol)
    (error "~a is not of type SYMBOL" symbol))
  (intern (format nil "~a" symbol) :keyword))
#+end_src

#+RESULTS:
: SYMBOL->KEYWORD

** Convertendo strings para keywords

Esta função é similar à anterior, porém converte uma certa string para
uma keyword.  Esta operação é  útil na formatação do  payload recebido
via requisição POST, mas não é usado diretamente.

#+begin_src lisp
(defun string->keyword (string)
    "Transforms a specific STRING into a keyword.
The string is trimmed and transformed to uppercase."
  (unless (stringp string)
    (error "~a is not of type STRING" string))
  (intern (->> string
               (string-trim '(#\Space #\Return))
               string-upcase)
          :keyword))
#+end_src

#+RESULTS:
: STRING->KEYWORD

** Reescrevendo alist com pares em keywords

Esta  função toma  uma alist  (proveniente de  uma requisição  POST) e
reestrutura-a, transformando cada uma das chaves em uma KEYWORD.

#+begin_src lisp
(defun restructure-alist (alist)
  "Restructures an ALIST (possibly received
by POST request into a proper alist.

Every key in the ALIST is converted from
string to keyword."
  (loop for (a . b) in alist
     collect (cons (string->keyword a) b)))
#+end_src

#+RESULTS:
: RESTRUCTURE-ALIST

** Tomando o payload do Ningle

Esta função exportada toma um objeto de requisição do Ningle e retorna
o payload da requisição, na forma  de uma alist reestruturada para que
as chaves sejam KEYWORDS.

#+begin_src lisp
(defun get-payload (request)
  "Takes a Ningle REQUEST object and
retrieves its payload (body parameters), as
a restructured alist fitting the rest of the
application."
  (restructure-alist
   (lack.request:request-body-parameters request)))
#+end_src

#+RESULTS:
: GET-PAYLOAD

** Detectando se uma classe é realmente uma tabela

Esta função  toma uma  certa classe  e verifica se  esta é  uma /table/,
segundo definida pelo ~mito~.

#+begin_src lisp
(defun class-table-p (class)
  "Tests whether a given CLASS is declared as a
table for the database, regardless if it exists
on the database or not.

CLASS can either be a symbol for the class or
the class itself, resolved by using the
FIND-CLASS function."
  (let ((class (if (typep class 'symbol)
                   (find-class class)
                   class)))
    (typep class 'mito.dao.table:dao-table-class)))
#+end_src

#+RESULTS:
: CLASS-TABLE-P

** Extraindo lista de slots de uma tabela

As funções a seguir foram desenhadas  para que fosse possível obter as
colunas de uma certa tabela, quando definida como uma classe.

*** Colunas cruas

Esta função é interna, e toma as colunas "cruas" da tabela, isto é, os
objetos que representam colunas em si.

Aqui  usaremos um  pouco  das  boas práticas  de  Clojure, através  do
threading macro =->>=. Isto possibilita encadear operações, de forma que
o resultado da operação anterior seja o último argumento da próxima.

#+begin_src lisp
(defun table-get-raw-columns (class)
  "Retrieves all the valid columns from a given
CLASS, as class slots.

CLASS can either be a symbol for the class or
the class itself, resolved by using the
FIND-CLASS function."
  (unless (class-table-p class)
    (error "~a is not a table class" class))
  (let* ((class (if (typep class 'symbol)
                    (find-class class)
                    class)))
    (->> class
         closer-mop:class-direct-superclasses
         (cons class)
         (mapcar #'closer-mop:class-direct-slots)
         alexandria:flatten
         (remove-if-not
          (lambda (slot)
            (typep slot
                   'mito.dao.column:dao-table-column-class)))
         (mapcar #'closer-mop:slot-definition-name))))
#+end_src

#+RESULTS:
: TABLE-GET-RAW-COLUMNS

*** Colunas em alists

Esta função  toma os nomes  de todas as colunas  de uma tabela  em uma
lista, em forma de /keywords/.

#+begin_src lisp
(defun table-get-lispy-columns (class)
  "Returns all the columns from a given CLASS,
as a list of keywords.

CLASS can either be a symbol for the class or
the class itself, resolved by using the
FIND-CLASS function."
  (mapcar #'symbol->keyword
          (table-get-raw-columns class)))
#+end_src

#+RESULTS:
: TABLE-GET-LISPY-COLUMNS

*** Colunas em alists para registro

Esta função toma as colunas de  uma tabela como /keywords/, e filtra-as,
removendo as colunas criadas automaticamente por ~mito~.

Estas colunas  podem ser utilizadas  para avaliar dados de  entrada de
registros, uma vez que são os nomes das informações esperadas, a serem
fornecidas durante seu registro.

#+begin_src lisp
(defparameter *non-register-columns*
  '(:created-at :updated-at :id :password-hash :password-salt)
  "List of keyword columns which are not considered
when creating a database entity from scratch.")

(defun table-get-lispy-register-columns (class)
  "Returns all the columns from a given CLASS,
as a list of keywords, removing the ones that
are not required for creating a new entity from
scratch.

CLASS can either be a symbol for the class or
the class itself, resolved by using the
FIND-CLASS function."
  (remove-if (lambda (slot)
               (member slot *non-register-columns* :test #'eql))
             (table-get-lispy-columns class)))
#+end_src

#+RESULTS:
: TABLE-GET-LISPY-REGISTER-COLUMNS

*** Colunas em string

Esta função  é igual à  sua versão "lispada",  com a diferença  que as
colunas apresentam-se como /strings/ em letra minúscula.

#+begin_src lisp
(defun table-get-string-columns (class)
  "Returns all the columns from a given CLASS,
as a list of strings.

CLASS can either be a symbol for the class or
the class itself, resolved by using the
FIND-CLASS function."
  (mapcar (lambda (x) (string-downcase (format nil "~a" x)))
          (table-get-lispy-columns class)))
#+end_src

#+RESULTS:
: TABLE-GET-STRING-COLUMNS

*** Colunas em string para registro

Esta função também  é similar à sua versão "lispada",  e também filtra
as colunas para que sejam as requeridas durante o processo de registro
na tabela em questão.

#+begin_src lisp
(defun table-get-string-register-columns (class)
  "Returns all the columns from a given CLASS,
as a list of strings, removing the ones that are
not required for creating a new entity from scratch.

CLASS can either be a symbol for the class or
the class itself, resolved by using the
FIND-CLASS function."
  (mapcar (lambda (x) (string-downcase (format nil "~a" x)))
          (table-get-lispy-register-columns class)))
#+end_src

#+RESULTS:
: TABLE-GET-STRING-REGISTER-COLUMNS

** Validando uma alist de registro

Esta função valida  uma alist de dados genérica segundo  as colunas de
registro  da  tabela  representada  por uma  classe,  que  deverá  ser
igualmente informada.

#+begin_src lisp
(defun post-valid-data-p (class data &key (has-password nil))
  "Tests whether some DATA received from a POST
request is valid for creating an entity of a specific
table CLASS.

HAS-PASSWORD determines whether this data requires password
authentication. If so, this predicate obligatorily checks for
presence of a :password field.

DATA must be an alist of values, and CLASS must be
one of the declared tables for the application."
  (let ((fields (append
                 (table-get-lispy-register-columns class)
                 (if has-password '(:password) nil))))
    (loop for field in data
       always (and (consp field)
                   (stringp (cdr field))
                   (member (car field) fields)))))
#+end_src

#+RESULTS:
: POST-VALID-DATA-P

** Obtendo campos de um DAO

A função  a seguir  toma um  objeto instanciado a  partir de  dados do
banco de dados,  verifica sua classe correspondente, e  cria uma /alist/
com dados  correspondentes a  suas colunas. Note  que esta  função não
filtra informações potencialmente sensíveis.

#+begin_src lisp
(defun dao->alist (dao)
  "Takes an entity DAO and turns it into an alist.

DAO must be a valid entity.

The returned alist is a list of CONS pairs, where
CAR is a keyword identifier for a field, and CDR
is the value itself."
  (let ((class (type-of dao)))
    (loop for field in (util:table-get-lispy-columns class)
       for getter-sym =
         (case field
           (:id 'mito:object-id)
           (:created-at    'mito:object-created-at)
           (:updated-at    'mito:object-updated-at)
           (:password-hash 'mito-auth:password-hash)
           (:password-salt 'mito-auth:password-salt)
           (otherwise
            (intern (string-upcase
                     (concatenate 'string
                                  (format nil "~a" class)
                                  "-"
                                  (format nil "~a" field)))
                    :rest-server.db)))
       collect (cons field (funcall getter-sym dao)))))
#+end_src

#+RESULTS:
: DAO->ALIST

** Censurando informações sensíveis em uma alist

A  função a  seguir  /filtra/ campos  de uma  alist  que possuam  chaves
censuradas.  Para  tanto, basta  fornecer  a  alist  e uma  lista  com
keywords censuradas.

#+begin_src lisp
(defun filter-alist (alist censored-keys)
  "Filters the fields from ALIST, given the
CENSORED-KEYS.

Returns a new alist, removing the fields which
keyword keys are in CENSORED-KEYS."
  (loop for element in alist
     unless (member (car element)
                    censored-keys
                    :test #'equal)
     collect element))
#+end_src

** Campos censurados em um DAO

Este parâmetro  define campos que normalmente  não seriam apresentados
ao usuário, quando obtidos através de uma rota.

#+begin_src lisp
(defparameter *censored-dao-fields*
  '(:created-at :updated-at :password-hash :password-salt)
  "Lists fields which are not supposed to be show
to someone attempting to retrieve a field.")
#+end_src

** Obtendo campos filtrados de um DAO

Esta função apresenta resultados  similares a ~dao->alist~. Todavia, ela
/filtra/ e remove  todos os campos que  sejam informações potencialmente
sensíveis.

#+begin_src lisp
(defun dao->filtered-alist (dao)
  "Takes an entity DAO and turns it into a
filtered alist, removing fields which are censored
for the end-user.

DAO must be a valid entity.

The returned alist is a list of CONS pairs, where
CAR is a keyword identifier for a field, and CDR
is the value itself."
  (->> *censored-dao-fields*
       (filter-alist (dao->alist dao))))
#+end_src

** Obtendo JSON de um DAO do banco de dados

Esta função  toma um  objeto populado  com dados do  banco de  dados e
transforma-o em  uma string  JSON. Como  JSON é  um formato  apenas de
comunicação para com  esta aplicação, o JSON  gerado é automaticamente
filtrado para que não contenha informações sensíveis.

#+begin_src lisp
(defun dao->json (dao)
  "Takes an entity DAO and turns it into a
JSON-formatted string, less the fields which are
censored for the end-user.

DAO must be a valid entity.

The returned JSON is formatted as an object,
where the keys are string identifiers for fields,
and the associated values are the expected values
themselves."
  (json:encode-json-to-string
   (dao->filtered-alist dao)))
#+end_src

